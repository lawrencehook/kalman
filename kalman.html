<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Kalman Filter Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .main-container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
            align-items: flex-start;
        }
        .viz-container {
            flex: 1;
        }
        #canvas {
            border: 1px solid #444;
            background: #0a0a0a;
            display: block;
            margin: 20px auto;
        }
        #errorGraph {
            border: 1px solid #444;
            background: #0a0a0a;
            display: block;
            margin: 0 auto;
        }
        .error-graph-container {
            margin: 20px 0;
        }
        .error-legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 10px 0 20px;
        }
        .controls {
            max-width: 800px;
            margin: 0 auto 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        .system-matrices {
            max-width: 1200px;
            margin: 0 auto 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        .state-panel {
            width: 350px;
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Matrix Display Styles */
        .matrix-container {
            display: inline-block;
            position: relative;
            margin: 10px;
            font-family: 'Courier New', monospace;
        }

        .matrix-brackets {
            position: relative;
            display: inline-block;
        }

        .matrix-brackets::before,
        .matrix-brackets::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 8px;
            border: 2px solid #4af;
            border-left: none;
            border-right: none;
        }

        .matrix-brackets::before {
            left: -10px;
            border-left: 2px solid #4af;
        }

        .matrix-brackets::after {
            right: -10px;
            border-right: 2px solid #4af;
        }

        .matrix-grid {
            display: grid;
            gap: 6px 10px;
            padding: 8px 15px;
            align-items: center;
            justify-items: center;
        }

        .matrix-2x2 { grid-template-columns: repeat(2, 1fr); }
        .matrix-2x6 { grid-template-columns: repeat(6, 1fr); }
        .matrix-6x2 { grid-template-columns: repeat(2, 1fr); }
        .matrix-6x6 { grid-template-columns: repeat(6, 1fr); }

        .matrix-cell {
            font-size: 10px;
            color: #0ff;
            text-align: center;
            min-width: 42px;
            white-space: nowrap;
        }

        .matrix-cell.inactive {
            color: #666;
        }

        .matrix-title {
            color: #4af;
            font-size: 13px;
            margin-bottom: 5px;
            text-align: center;
            font-family: Arial, sans-serif;
        }

        .matrices-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 25px;
            margin-top: 15px;
        }

        .matrix-display {
            text-align: center;
            background: #1a1a1a;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #333;
        }

        h2[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            border: 1px solid #4af;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            line-height: 1.4;
            width: 280px;
            z-index: 100;
            pointer-events: none;
            margin-top: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            font-weight: normal;
            font-family: Arial, sans-serif;
        }
        h2[data-tooltip] {
            position: relative;
        }
        .state-panel h2:hover::after {
            content: "The Kalman filter waits to gather a few measurements, then initializes its state with data-derived position/velocity/acceleration. Until then it does not predict.";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            border: 1px solid #4af;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            line-height: 1.4;
            width: 280px;
            z-index: 100;
            pointer-events: none;
            margin-top: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            font-weight: normal;
            font-family: Arial, sans-serif;
        }
        .state-section {
            margin-bottom: 20px;
        }
        .state-section h3 {
            color: #4af;
            margin: 0 0 10px 0;
            font-size: 14px;
            font-family: Arial, sans-serif;
            cursor: help;
            position: relative;
        }
        .state-section h3:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 0;
            background: #1a1a1a;
            border: 1px solid #4af;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            line-height: 1.4;
            width: 280px;
            z-index: 100;
            pointer-events: none;
            margin-bottom: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            font-weight: normal;
        }
        .state-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        .state-label {
            color: #aaa;
            position: relative;
            cursor: help;
        }
        .state-label:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 0;
            background: #1a1a1a;
            border: 1px solid #4af;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            line-height: 1.4;
            width: 250px;
            z-index: 100;
            pointer-events: none;
            margin-bottom: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        .state-value {
            color: #0ff;
            text-align: right;
        }
        .state-value.inactive {
            color: #666;
        }
        .slider-container label {
            cursor: help;
            position: relative;
        }
        .slider-container label:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 0;
            background: #1a1a1a;
            border: 1px solid #4af;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            line-height: 1.4;
            width: 300px;
            z-index: 100;
            pointer-events: none;
            margin-bottom: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        .measurement-indicator {
            padding: 5px;
            margin: 10px 0;
            background: #3a2a4a;
            border-radius: 4px;
            text-align: center;
            color: #f0f;
        }
        .no-measurement {
            background: #2a3a3a;
            color: #888;
        }
        .bootstrapping {
            background: #3a3a2a;
            color: #ffea70;
        }
        .slider-container {
            margin: 15px 0;
        }
        label {
            display: inline-block;
            width: 200px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 300px;
            vertical-align: middle;
        }
        .value {
            display: inline-block;
            width: 60px;
            text-align: right;
            color: #4af;
        }
        .legend {
            margin: 20px auto 10px;
            max-width: 1400px;
            display: flex;
            justify-content: center;
            gap: 30px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 20px;
            height: 3px;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            background: #4af;
            border: none;
            border-radius: 4px;
            color: #000;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: #6cf;
        }
        .toggle-section {
            color: #4af;
            cursor: pointer;
            padding: 10px;
            background: #333;
            border-radius: 4px;
            text-align: center;
            margin: 15px 0;
            user-select: none;
        }
        .toggle-section:hover {
            background: #444;
        }
        .matrices-section {
            display: none;
            margin-top: 15px;
        }
        .matrices-section.visible {
            display: block;
        }
        .equation-section {
            margin: 15px 0;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 4px;
            border-left: 3px solid #4af;
        }
        .eq-label {
            color: #4af;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .equation-line {
            font-family: 'Courier New', monospace;
            color: #0ff;
            margin: 4px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">2D Kalman Filter - Multi-Shape Tracking</h1>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #0f0;"></div>
            <span>Ground Truth</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f0f;"></div>
            <span>Measurements</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0ff; width: 6px; height: 6px; border-radius: 3px;"></div>
            <span>Kalman Estimates</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(0,255,255,0.3);"></div>
            <span>95% Confidence</span>
        </div>
    </div>

    <div class="main-container">
        <div class="viz-container">
            <canvas id="canvas" width="800" height="600"></canvas>

            <!-- Error Graph -->
            <div class="error-graph-container">
                <h3 style="text-align: center; color: #4af; margin: 20px 0 10px 0;">Position Error vs 95% Confidence Bound</h3>
                <canvas id="errorGraph" width="800" height="200"></canvas>
                <div class="error-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f44;"></div>
                        <span>Actual Error</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #fa4;"></div>
                        <span>95% Confidence Bound</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4af; width: 2px; height: 20px;"></div>
                        <span>Current Time</span>
                    </div>
                </div>
            </div>

            <div class="controls">
                <div class="slider-container">
                    <label data-tooltip="Select the trajectory shape for the object to follow. Different shapes test various aspects of the filter's performance.">Trajectory Shape:</label>
                    <select id="trajectorySelect" style="width: 220px; padding: 4px; background: #333; color: #fff; border: 1px solid #666; border-radius: 4px;">
                        <!-- Best matches for Constant-Acceleration model -->
                        <option value="constaccel_line">Const-Accel Diagonal</option>
                        <option value="constaccel_bezier">Const-Accel Bezier</option>
                        <option value="constantacceleration">Constant Acceleration Line</option>
                        <option value="constantvelocity">Constant Velocity Line</option>
                        <option value="sinewave">Sine Wave</option>
                        <option value="parabolic">Parabolic Arc</option>

                        <!-- Smooth but changing acceleration direction/magnitude -->
                        <option value="circle">Circle</option>
                        <option value="lissajous">Lissajous</option>
                        <option value="figure8">Figure-8</option>
                        <option value="infinity">Infinity (∞)</option>
                        <option value="clothoid">Euler Spiral (Clothoid)</option>
                        <option value="spiral">Spiral</option>
                        <option value="heart">Heart</option>
                        <option value="rfsmooth">Random Fourier (Smooth)</option>

                        <!-- Discontinuities/sharp corners or stochastic -->
                        <option value="stopandgo">Stop and Go</option>
                        <option value="stepfunction">Step Function</option>
                        <option value="square">Square</option>
                        <option value="star">Star</option>
                        <option value="randomwalk">Random Walk</option>
                    </select>
                </div>

                <div class="slider-container">
                    <label data-tooltip="Current simulation time. The filter runs at 20Hz (every 0.05s) while measurements arrive at 10Hz (every 0.1s). The object completes multiple trajectory patterns over 30 seconds.">Time:</label>
                    <input type="range" id="timeSlider" min="0" max="100" value="0" step="1">
                    <span class="value" id="timeValue">0.00s</span>
                </div>

                <div class="slider-container">
                    <label data-tooltip="Standard deviation of noise added to position measurements. Higher values make measurements less reliable, causing the filter to trust its model more.">Measurement Noise (σ):</label>
                    <input type="range" id="measurementNoise" min="1" max="50" value="5" step="1">
                    <span class="value" id="measurementNoiseValue">15</span>
                </div>

                <div class="slider-container">
                    <label data-tooltip="Uncertainty in the motion model. Higher values mean the filter expects more random accelerations, making it trust measurements more and predictions less.">Process Noise:</label>
                    <input type="range" id="processNoise" min="0.1" max="5" value="1" step="0.1">
                    <span class="value" id="processNoiseValue">1.0</span>
                </div>

                <div style="text-align: center; margin-top: 20px;">
                    <button id="playBtn">Play/Pause</button>
                    <button id="stepBtn">Step</button>
                    <button id="resetBtn">Reset</button>
                </div>

                <!-- Fixed, whole-duration metric -->
                <div class="slider-container">
                    <label data-tooltip="Coverage over the entire simulated duration: fraction of timestamps where ground truth is inside the estimate's 95% error ellipse (Mahalanobis distance² ≤ 5.991).">
                        Total Ellipse Coverage (95%):
                    </label>
                    <span class="value" id="total-coverage-95">--</span>
                </div>
            </div>
        </div>

        <div class="state-panel">
            <h2 style="color: #4af; text-align: center; margin-top: 0; cursor: help;" data-tooltip="The Kalman filter waits for a few measurements to initialize, then fuses measurements with the motion model.">Filter State</h2>

            <div id="measurementStatus" class="measurement-indicator bootstrapping">
                Bootstrapping (0/3)
            </div>

            <div class="state-section">
                <h3 data-tooltip="The filter's current estimate of the object's state, including position, velocity, and acceleration in both X and Y dimensions.">State Vector x̂</h3>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated X position of the object in pixels from center">Position X:</span>
                    <span class="state-value" id="state-x">--</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated Y position of the object in pixels from center">Position Y:</span>
                    <span class="state-value" id="state-y">--</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated velocity in X direction (pixels per second)">Velocity X:</span>
                    <span class="state-value" id="state-vx">--</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated velocity in Y direction (pixels per second)">Velocity Y:</span>
                    <span class="state-value" id="state-vy">--</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated acceleration in X direction (pixels per second²)">Accel X:</span>
                    <span class="state-value" id="state-ax">--</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated acceleration in Y direction (pixels per second²)">Accel Y:</span>
                    <span class="state-value" id="state-ay">--</span>
                </div>
            </div>

            <div class="state-section">
                <h3 data-tooltip="The covariance matrix quantifies the uncertainty in position estimates. Larger values mean less confidence. The ellipse visualization is derived from this matrix.">Position Covariance P</h3>
                <div class="matrix-container">
                    <div class="matrix-brackets">
                        <div class="matrix-grid matrix-2x2">
                            <div class="matrix-cell" id="p00">--</div>
                            <div class="matrix-cell" id="p01">--</div>
                            <div class="matrix-cell" id="p10">--</div>
                            <div class="matrix-cell" id="p11">--</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="state-section">
                <h3 data-tooltip="Metrics comparing the filter's estimates to ground truth and showing the filter's confidence levels.">Error Metrics</h3>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Euclidean distance between the filter estimate and ground truth position">Position Error:</span>
                    <span class="state-value" id="pos-error">--</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Square root of X variance from covariance matrix. Represents 1-sigma uncertainty in X direction">Std Dev X:</span>
                    <span class="state-value" id="std-x">--</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Square root of Y variance from covariance matrix. Represents 1-sigma uncertainty in Y direction">Std Dev Y:</span>
                    <span class="state-value" id="std-y">--</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Share of time (up to current t) that the true position lay inside the filter's 95% error ellipse (Mahalanobis distance² ≤ χ²₂,0.95 ≈ 5.991).">
                        Ellipse Coverage (95%):
                    </span>
                    <span class="state-value" id="coverage-95">--</span>
                </div>
            </div>

            <div class="state-section">
                <h3 data-tooltip="The innovation (or residual) is the difference between what was measured and what the filter predicted. Large innovations indicate surprising measurements.">Innovation (Residual)</h3>
                <div class="matrix-container">
                    <div class="matrix-brackets">
                        <div class="matrix-grid matrix-2x1" style="grid-template-columns: 1fr;">
                            <div class="matrix-cell" id="innovation-x">--</div>
                            <div class="matrix-cell" id="innovation-y">--</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="state-section">
                <h3 data-tooltip="The Kalman gain determines how much the filter trusts new measurements versus its predictions. Higher values mean more trust in measurements, lower values mean more trust in the model.">Kalman Gain K</h3>
                <div class="matrix-container">
                    <div class="matrix-brackets">
                        <div class="matrix-grid matrix-6x2">
                            <div class="matrix-cell" id="k00">--</div>
                            <div class="matrix-cell" id="k01">--</div>
                            <div class="matrix-cell" id="k10">--</div>
                            <div class="matrix-cell" id="k11">--</div>
                            <div class="matrix-cell" id="k20">--</div>
                            <div class="matrix-cell" id="k21">--</div>
                            <div class="matrix-cell" id="k30">--</div>
                            <div class="matrix-cell" id="k31">--</div>
                            <div class="matrix-cell" id="k40">--</div>
                            <div class="matrix-cell" id="k41">--</div>
                            <div class="matrix-cell" id="k50">--</div>
                            <div class="matrix-cell" id="k51">--</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- System Matrices Section -->
    <div class="system-matrices">
        <div class="toggle-section" id="toggleMatrices">
            Show System Matrices & Equations ▼
        </div>

        <div class="matrices-section" id="matricesSection">
            <div class="matrices-grid">
                <div class="matrix-display">
                    <div class="matrix-title">State Transition F (6×6)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">Predicts next state from current state</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-F" class="matrix-grid matrix-6x6"></div>
                        </div>
                    </div>
                </div>

                <div class="matrix-display">
                    <div class="matrix-title">Measurement H (2×6)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">Maps state to expected measurement (extracts position)</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-H" class="matrix-grid matrix-2x6"></div>
                        </div>
                    </div>
                </div>

                <div class="matrix-display">
                    <div class="matrix-title">Process Noise Q (6×6)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">Uncertainty added during prediction</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-Q" class="matrix-grid matrix-6x6"></div>
                        </div>
                    </div>
                </div>

                <div class="matrix-display">
                    <div class="matrix-title">Measurement Noise R (2×2)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">Expected measurement uncertainty</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-R" class="matrix-grid matrix-2x2"></div>
                        </div>
                    </div>
                </div>

                <div class="matrix-display">
                    <div class="matrix-title">Full Covariance P (6×6)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">Uncertainty in all state variables</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-P-full" class="matrix-grid matrix-6x6"></div>
                        </div>
                    </div>
                </div>

                <div class="matrix-display">
                    <div class="matrix-title">Innovation Covariance S (2×2)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">S = H×P×H<sup>T</sup> + R (measurement prediction uncertainty)</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-S" class="matrix-grid matrix-2x2"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="state-section">
                <h3 data-tooltip="The mathematical operations performed during prediction and update steps">Filter Equations</h3>

                <div class="equation-section">
                    <div class="eq-label">Prediction Step (every 0.05s):</div>
                    <div class="equation-line">x̂ₖ₊₁|ₖ = F × x̂ₖ|ₖ</div>
                    <div class="equation-line">Pₖ₊₁|ₖ = F × Pₖ|ₖ × F<sup>T</sup> + Q</div>
                </div>

                <div class="equation-section" id="updateEquations">
                    <div class="eq-label">Update Step (when measurement arrives):</div>
                    <div class="equation-line">yₖ = zₖ - H × x̂ₖ|ₖ₋₁ (innovation)</div>
                    <div class="equation-line">Sₖ = H × Pₖ|ₖ₋₁ × H<sup>T</sup> + R</div>
                    <div class="equation-line">Kₖ = Pₖ|ₖ₋₁ × H<sup>T</sup> × Sₖ⁻¹</div>
                    <div class="equation-line">x̂ₖ|ₖ = x̂ₖ|ₖ₋₁ + Kₖ × yₖ</div>
                    <div class="equation-line">Pₖ|ₖ = (I - Kₖ × H) × Pₖ|ₖ₋₁</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ================================
        // UTILITY MODULES
        // ================================

        class MatrixUtils {
            static multiply(A, B) {
                const m = A.length, n = A[0].length, p = B[0].length;
                const C = Array(m).fill().map(() => Array(p).fill(0));
                for (let i = 0; i < m; i++) {
                    for (let j = 0; j < p; j++) {
                        for (let k = 0; k < n; k++) {
                            C[i][j] += A[i][k] * B[k][j];
                        }
                    }
                }
                return C;
            }

            static transpose(A) {
                return A[0].map((_, i) => A.map(row => row[i]));
            }

            static add(A, B) {
                return A.map((row, i) => row.map((val, j) => val + B[i][j]));
            }

            static subtract(A, B) {
                return A.map((row, i) => row.map((val, j) => val - B[i][j]));
            }

            static inverse2x2(A) {
                const det = A[0][0] * A[1][1] - A[0][1] * A[1][0];
                return [
                    [A[1][1] / det, -A[0][1] / det],
                    [-A[1][0] / det, A[0][0] / det]
                ];
            }

            static identity(n) {
                return Array(n).fill().map((_, i) =>
                    Array(n).fill().map((_, j) => i === j ? 1 : 0)
                );
            }

            static extractSubmatrix(matrix, startRow, endRow, startCol, endCol) {
                return matrix.slice(startRow, endRow + 1)
                    .map(row => row.slice(startCol, endCol + 1));
            }
        }

        class NoiseUtils {
            static gaussian(sigma = 1.0) {
                const u = Math.random();
                const v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v) * sigma;
            }

            static addGaussianNoise(position, sigma) {
                return [
                    position[0] + this.gaussian(sigma),
                    position[1] + this.gaussian(sigma)
                ];
            }
        }

        // ================================
        // DATA GENERATOR INTERFACES
        // ================================

        class TrajectoryGenerator {
            constructor(config = {}) {
                this.config = { maxTime: 30, scale: 150, ...config };
            }
            generatePosition(t) { throw new Error('generatePosition must be implemented by subclass'); }
            getName() { return 'Generic Trajectory'; }
        }

        class Figure8Generator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const phase = t * 3 * 2 * Math.PI / maxTime;
                const x = scale * Math.sin(phase);
                const y = scale * Math.sin(phase) * Math.cos(phase);
                return [x, y];
            }
            getName() { return 'Figure-8'; }
        }

        class CircleGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const phase = t * 2 * Math.PI / (maxTime / 3);
                const x = scale * Math.cos(phase);
                const y = scale * Math.sin(phase);
                return [x, y];
            }
            getName() { return 'Circle'; }
        }

        class SquareGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const cycleTime = maxTime / 3;
                const phase = Math.min(Math.max(t / maxTime, 0), 1); // single arc over full duration [0,1]

                if (phase < 0.25) {
                    const progress = phase / 0.25; return [scale * (progress * 2 - 1), scale];
                } else if (phase < 0.5) {
                    const progress = (phase - 0.25) / 0.25; return [scale, scale * (1 - progress * 2)];
                } else if (phase < 0.75) {
                    const progress = (phase - 0.5) / 0.25; return [scale * (1 - progress * 2), -scale];
                } else {
                    const progress = (phase - 0.75) / 0.25; return [-scale, scale * (progress * 2 - 1)];
                }
            }
            getName() { return 'Square'; }
        }

        class SpiralGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const phase = t * 4 * Math.PI / maxTime;
                const radius = scale * (0.2 + 0.8 * t / maxTime);
                const x = radius * Math.cos(phase);
                const y = radius * Math.sin(phase);
                return [x, y];
            }
            getName() { return 'Spiral'; }
        }

        class HeartGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const phase = t * 6 * Math.PI / maxTime;
                const x = scale * 0.8 * (16 * Math.sin(phase)**3) / 16;
                const y = scale * 0.8 * (13 * Math.cos(phase) - 5 * Math.cos(2*phase) - 2 * Math.cos(3*phase) - Math.cos(4*phase)) / 16;
                return [x, -y];
            }
            getName() { return 'Heart'; }
        }

        class StarGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const cycleTime = maxTime / 2;
                const phase = ((t % cycleTime) / cycleTime) * 10;
                const pointIndex = Math.floor(phase);
                const progress = phase - pointIndex;

                const outerRadius = scale;
                const innerRadius = scale * 0.4;

                const getStarPoint = (index, outer) => {
                    const angle = (index * 2 * Math.PI / 10) - Math.PI / 2;
                    const radius = outer ? outerRadius : innerRadius;
                    return [radius * Math.cos(angle), radius * Math.sin(angle)];
                };

                const isOuter = pointIndex % 2 === 0;
                const currentPoint = getStarPoint(pointIndex, isOuter);
                const nextPoint = getStarPoint((pointIndex + 1) % 10, !isOuter);

                const x = currentPoint[0] + progress * (nextPoint[0] - currentPoint[0]);
                const y = currentPoint[1] + progress * (nextPoint[1] - currentPoint[1]);
                return [x, y];
            }
            getName() { return 'Star'; }
        }

        class RandomWalkGenerator extends TrajectoryGenerator {
            constructor(config = {}) { super(config); this.positions = []; this.generateWalk(); }
            generateWalk() {
                const { maxTime, scale } = this.config;
                const dt = 0.05;
                const steps = Math.ceil(maxTime / dt);
                const stepSize = scale * 0.02;
                let x = 0, y = 0;
                this.positions = [];
                for (let i = 0; i <= steps; i++) {
                    this.positions.push([x, y]);
                    const angle = Math.random() * 2 * Math.PI;
                    x += stepSize * Math.cos(angle);
                    y += stepSize * Math.sin(angle);
                    const maxPos = scale * 1.2;
                    x = Math.max(-maxPos, Math.min(maxPos, x));
                    y = Math.max(-maxPos, Math.min(maxPos, y));
                }
            }
            generatePosition(t) {
                const dt = 0.05;
                const index = Math.min(Math.floor(t / dt), this.positions.length - 1);
                return this.positions[index];
            }
            getName() { return 'Random Walk'; }
        }

        class InfinityGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const phase = t * 6 * Math.PI / maxTime;
                const x = scale * Math.cos(phase) / (1 + Math.sin(phase)**2);
                const y = scale * Math.sin(phase) * Math.cos(phase) / (1 + Math.sin(phase)**2);
                return [x, y];
            }
            getName() { return 'Infinity (∞)'; }
        }

        class ConstantVelocityGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const phase = Math.min(Math.max(t / maxTime, 0), 1); // 0→1 over run
                const x = -scale + 2*scale*phase; // left to right exactly once
                const y = 0;
                return [x, y];
            }
            getName() { return 'Constant Velocity Line'; }
        }

        class ConstantAccelerationGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const phase = Math.min(Math.max(t / maxTime, 0), 1); // 0→1
                // constant accel from rest: x(t) = x0 + 0.5 a t²
                const x0 = -scale;
                const xf = scale;
                const T = maxTime;
                const a = 2*(xf - x0)/(T*T);  // so that x(T)=xf
                const x = x0 + 0.5*a*t*t;
                const y = 0;
                return [x, y];
            }
            getName() { return 'Constant Acceleration Line'; }
        }

        class SineWaveGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const frequency = 6 / maxTime;
                const x = scale * Math.sin(2 * Math.PI * frequency * t);
                const y = 0;
                return [x, y];
            }
            getName() { return 'Sine Wave'; }
        }

        class ParabolicGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const cycleTime = maxTime / 2;
                const phase = Math.min(Math.max(t / maxTime, 0), 1); // single arc over full duration [0,1]
                const x = scale * (phase * 2 - 1);
                const height = scale * 0.8;
                const y = height * (1 - 4 * phase * (1 - phase));
                return [x, y];
            }
            getName() { return 'Parabolic Arc'; }
        }

        class StepFunctionGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const stepDuration = maxTime / 6;
                const stepIndex = Math.floor(t / stepDuration);
                const positions = [
                    [-scale, -scale * 0.5],
                    [scale, -scale * 0.5],
                    [-scale, scale * 0.5],
                    [scale, scale * 0.5],
                    [0, -scale],
                    [0, scale]
                ];
                return positions[stepIndex % positions.length];
            }
            getName() { return 'Step Function'; }
        }

        class StopAndGoGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const cycleDuration = maxTime / 4;
                const phase = (t % cycleDuration) / cycleDuration;
                let x, y;
                if (phase < 0.7) {
                    const movePhase = phase / 0.7;
                    const angle = (Math.floor(t / cycleDuration) % 4) * Math.PI / 2;
                    x = scale * movePhase * Math.cos(angle);
                    y = scale * movePhase * Math.sin(angle);
                } else {
                    const angle = (Math.floor(t / cycleDuration) % 4) * Math.PI / 2;
                    x = scale * Math.cos(angle);
                    y = scale * Math.sin(angle);
                }
                return [x, y];
            }
            getName() { return 'Stop and Go'; }
        }

        /**
         * Const-Accel Bezier (Quadratic) – zero jerk (C^2)
         * p(τ) = (1-τ)^2 P0 + 2(1-τ)τ C + τ^2 P1, τ = t/T
         * Quadratic in time ⇒ constant acceleration.
         */
        class ConstAccelBezierGenerator extends TrajectoryGenerator {
            constructor(config = {}) {
                super(config);
                const s = this.config.scale;
                // Endpoints left→right, control above center for a smooth arch
                this.P0 = [-s, 0];
                this.P1 = [ s, 0];
                this.C  = [ 0, -0.8*s ]; // negative y to arc upward on canvas
            }
            generatePosition(t) {
                const T = this.config.maxTime;
                const τ = Math.min(Math.max(t / T, 0), 1);
                const u = 1 - τ;
                const bx = u*u*this.P0[0] + 2*u*τ*this.C[0] + τ*τ*this.P1[0];
                const by = u*u*this.P0[1] + 2*u*τ*this.C[1] + τ*τ*this.P1[1];
                return [bx, by];
            }
            getName() { return 'Const-Accel Bezier'; }
        }

        /**
         * Const-Accel Diagonal – zero jerk
         * Start at (-s,-s), end at (+s,+s) with v0=0, a chosen so x(T)=xf, y(T)=yf.
         * x(t) = x0 + 0.5 a_x t^2,  a_x = 2(xf-x0)/T^2  (same for y).
         */
        class ConstAccelLineGenerator extends TrajectoryGenerator {
            constructor(config = {}) {
                super(config);
                const s = this.config.scale;
                this.x0 = -s; this.y0 = -s;
                this.xf =  s; this.yf =  s;
                const T = this.config.maxTime;
                this.ax = 2*(this.xf - this.x0)/(T*T);
                this.ay = 2*(this.yf - this.y0)/(T*T);
            }
            generatePosition(t) {
                const x = this.x0 + 0.5*this.ax*t*t;
                const y = this.y0 + 0.5*this.ay*t*t;
                return [x, y];
            }
            getName() { return 'Const-Accel Diagonal'; }
        }

        /**
         * Minimum-Jerk Arc (C∞)
         * s(τ) = 10τ^3 − 15τ^4 + 6τ^5, τ∈[0,1]
         * Moves from (-scale,0) to (+scale,0) with a smooth arch in Y.
         * Real-world: human arm/robot point-to-point profiles.
         */
        class MinimumJerkGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const tau = Math.min(Math.max(t / maxTime, 0), 1);
                const s = 10*tau**3 - 15*tau**4 + 6*tau**5; // C∞ easing
                const x = -scale + 2*scale*s;
                // smooth arch: C∞ bump via sine of eased progress
                const A = 0.6 * scale;
                const y = A * Math.sin(Math.PI * s);
                return [x, y];
            }
            getName() { return 'Minimum-Jerk Arc'; }
        }

        /**
         * Lissajous (C∞)
         * Real-world: smooth cross-axis oscillations (e.g., drone).
         */
        class LissajousGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                // 2 and 3 are co-prime => closed smooth figure over period
                const w = 2*Math.PI/(maxTime/1.5);
                const x = scale * Math.sin(2*w*t + Math.PI/6);
                const y = scale * 0.7 * Math.sin(3*w*t);
                return [x, y];
            }
            getName() { return 'Lissajous'; }
        }

        /**
         * Euler Spiral / Clothoid (C∞)
         * Curvature κ(s) increases linearly with arclength s.
         * We numerically integrate a constant speed path where
         * heading'(t) = κ0 + κ1 * s(t), with s'(t)=v.
         * Real-world: comfortable steering (roads, rail, vehicles).
         */
        class ClothoidGenerator extends TrajectoryGenerator {
            constructor(config = {}) {
                super(config);
                this.dt = 0.01;         // fine internal step for smooth precompute
                this.v  = (this.config.scale * 3) / this.config.maxTime; // avg speed
                this.k0 = 0.0;          // initial curvature
                this.k1 = (Math.PI / (this.config.scale * 2)) / (this.v * this.config.maxTime); // gentle ramp
                this.path = this.precomputePath();
            }
            precomputePath() {
                const N = Math.max(2, Math.floor(this.config.maxTime / this.dt));
                let x = -this.config.scale, y = 0, theta = 0, s = 0;
                const pts = [];
                for (let i = 0; i <= N; i++) {
                    pts.push([x, y]);
                    const kappa = this.k0 + this.k1 * s;   // κ(s) linear in arclength
                    theta += kappa * this.v * this.dt;     // dθ/dt = κ * v
                    x += this.v * Math.cos(theta) * this.dt;
                    y += this.v * Math.sin(theta) * this.dt;
                    s += this.v * this.dt;
                }
                // recentre roughly
                const cx = (pts[0][0] + pts[pts.length-1][0]) / 2;
                const cy = (pts[0][1] + pts[pts.length-1][1]) / 2;
                return pts.map(p => [p[0] - cx, p[1] - cy]);
            }
            generatePosition(t) {
                const idx = Math.min(
                    Math.floor((t / this.config.maxTime) * (this.path.length - 1)),
                    this.path.length - 1
                );
                return this.path[idx];
            }
            getName() { return 'Euler Spiral (Clothoid)'; }
        }

        /**
         * Random Fourier (Smooth) (C∞)
         * Low-frequency band-limited sum of sin/cos => smooth wandering path.
         * Real-world: "meandering animal/boat" with bounded speed/acc.
         */
        class RandomFourierSmoothGenerator extends TrajectoryGenerator {
            constructor(config = {}) {
                super(config);
                this.freqs = [1, 2, 3];    // very low harmonics over duration
                this.ax = this.freqs.map(() => (Math.random()*2-1));
                this.bx = this.freqs.map(() => (Math.random()*2-1));
                this.ay = this.freqs.map(() => (Math.random()*2-1));
                this.by = this.freqs.map(() => (Math.random()*2-1));
                // normalize amplitude so we don't exceed scale
                const norm = Math.sqrt(
                    [...this.ax, ...this.bx, ...this.ay, ...this.by]
                        .reduce((s,v)=>s+v*v,0) / (4*this.freqs.length)
                );
                const target = 0.7; // use 70% of scale
                this.gain = target / Math.max(norm, 1e-6);
            }
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const w0 = 2*Math.PI / maxTime; // base angular frequency
                let x = 0, y = 0;
                for (let i = 0; i < this.freqs.length; i++) {
                    const w = this.freqs[i] * w0;
                    x += this.ax[i]*Math.sin(w*t) + this.bx[i]*Math.cos(w*t);
                    y += this.ay[i]*Math.sin(w*t) + this.by[i]*Math.cos(w*t);
                }
                return [scale * this.gain * x, scale * this.gain * y];
            }
            getName() { return 'Random Fourier (Smooth)'; }
        }

        // ================================
        // FILTER INTERFACES
        // ================================

        class FilterBase {
            constructor(config = {}) {
                this.config = config;
                this.lastInnovation = null;
                this.lastKalmanGain = null;
                this.lastInnovationCovariance = null;
            }
            predict() { throw new Error('predict must be implemented by subclass'); }
            update(measurement) { throw new Error('update must be implemented by subclass'); }
            getState() { return this.state; }
            getPosition() {
                if (!this.state || this.state.length < 2) return null;
                return [this.state[0][0], this.state[1][0]];
            }
            getPositionCovariance() {
                if (!this.covariance) return null;
                return MatrixUtils.extractSubmatrix(this.covariance, 0, 1, 0, 1);
            }
            getSystemMatrices() { return {}; }
            getName() { return 'Generic Filter'; }
        }

        class KalmanFilter2D extends FilterBase {
            constructor(config = {}) {
                super(config);
                const { dt, measurementNoise, processNoise } = {
                    dt: 0.05, measurementNoise: 15, processNoise: 1, ...config
                };
                this.dt = dt;
                this.initialized = false;

                // State transition (constant acceleration)
                this.F = [
                    [1, 0, dt, 0, 0.5*dt*dt, 0],
                    [0, 1, 0, dt, 0, 0.5*dt*dt],
                    [0, 0, 1, 0, dt, 0],
                    [0, 0, 0, 1, 0, dt],
                    [0, 0, 0, 0, 1, 0],
                    [0, 0, 0, 0, 0, 1]
                ];

                // Measurement matrix (position only)
                this.H = [
                    [1, 0, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0, 0]
                ];

                // Start uninitialized: no state/covariance yet
                this.state = null;
                this.covariance = null;

                // Process noise
                this.processNoiseScalar = processNoise;
                this.measurementNoiseScalar = measurementNoise;
                this.rebuildNoise();
            }

            rebuildNoise() {
                const q = this.processNoiseScalar;
                const dt = this.dt;
                this.Q = [
                    [dt**4/4 * q, 0, dt**3/2 * q, 0, dt**2/2 * q, 0],
                    [0, dt**4/4 * q, 0, dt**3/2 * q, 0, dt**2/2 * q],
                    [dt**3/2 * q, 0, dt**2 * q, 0, dt * q, 0],
                    [0, dt**3/2 * q, 0, dt**2 * q, 0, dt * q],
                    [dt**2/2 * q, 0, dt * q, 0, q, 0],
                    [0, dt**2/2 * q, 0, dt * q, 0, q]
                ];
                const r = this.measurementNoiseScalar;
                this.R = [[r*r, 0], [0, r*r]];
            }

            setInitialState(x0, P0) {
                this.state = x0;         // 6x1
                this.covariance = P0;    // 6x6
                this.initialized = true;
            }

            predict() {
                if (!this.initialized) return; // no-op before init
                this.state = MatrixUtils.multiply(this.F, this.state);
                const FP = MatrixUtils.multiply(this.F, this.covariance);
                const FPFt = MatrixUtils.multiply(FP, MatrixUtils.transpose(this.F));
                this.covariance = MatrixUtils.add(FPFt, this.Q);
                this.lastInnovation = null;
                this.lastKalmanGain = null;
                this.lastInnovationCovariance = null;
            }

            update(measurement) {
                if (!this.initialized) return; // no-op before init
                const innovation = MatrixUtils.subtract(measurement, MatrixUtils.multiply(this.H, this.state));
                this.lastInnovation = innovation;

                const HP = MatrixUtils.multiply(this.H, this.covariance);
                const HPHt = MatrixUtils.multiply(HP, MatrixUtils.transpose(this.H));
                const S = MatrixUtils.add(HPHt, this.R);
                this.lastInnovationCovariance = S;

                const PHt = MatrixUtils.multiply(this.covariance, MatrixUtils.transpose(this.H));
                const K = MatrixUtils.multiply(PHt, MatrixUtils.inverse2x2(S));
                this.lastKalmanGain = K;

                const Ky = MatrixUtils.multiply(K, innovation);
                this.state = MatrixUtils.add(this.state, Ky);

                const KH = MatrixUtils.multiply(K, this.H);
                const I_KH = MatrixUtils.subtract(MatrixUtils.identity(6), KH);
                this.covariance = MatrixUtils.multiply(I_KH, this.covariance);
            }

            getSystemMatrices() { return { F: this.F, H: this.H, Q: this.Q, R: this.R }; }
            getName() { return 'Kalman Filter 2D'; }

            updateNoise(measurementNoise, processNoise) {
                this.processNoiseScalar = processNoise;
                this.measurementNoiseScalar = measurementNoise;
                this.rebuildNoise();
            }
        }

        // ================================
        // VISUALIZATION ENGINE
        // ================================

        class VisualizationEngine {
            constructor(canvasId, config = {}) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.config = {
                    fadeWindowSeconds: 6.0,
                    minAlpha: 0.15,
                    fadeSharpness: 2.5,
                    ...config
                };
                // Zoom / pan state
                this.scale = 1.0;
                this.panX = 0.0; // in world units (same units as positions)
                this.panY = 0.0;
                this.onViewChange = null; // callback to request a redraw

                // Drag state
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;

                // Mouse-wheel zoom (zoom at cursor position)
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    const zoomFactor = Math.exp(-e.deltaY * 0.001); // smooth zoom
                    this.zoomAt(mx, my, zoomFactor);
                }, { passive: false });

                // Drag-to-pan (mouse)
                this.canvas.style.cursor = 'grab';
                this.canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.isDragging = true;
                    this.canvas.style.cursor = 'grabbing';
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                });
                window.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return;
                    e.preventDefault();
                    const dx = e.clientX - this.lastMouseX;
                    const dy = e.clientY - this.lastMouseY;
                    // convert pixel delta to world units (inverse scale)
                    this.panX += dx / this.scale;
                    this.panY += dy / this.scale;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    this.requestRedraw();
                }, { passive: false });
                const endDrag = () => {
                    if (!this.isDragging) return;
                    this.isDragging = false;
                    this.canvas.style.cursor = 'grab';
                };
                window.addEventListener('mouseup', endDrag);
                this.canvas.addEventListener('mouseleave', (e) => {
                    if (!this.isDragging) return;
                    endDrag();
                });
            }

            // Allow external code to register a redraw callback
            setOnViewChange(cb) { this.onViewChange = cb; }
            requestRedraw() {
                if (typeof this.onViewChange === 'function') this.onViewChange();
            }

            // Reset zoom/pan to defaults
            resetView() {
                this.scale = 1.0;
                this.panX = 0.0;
                this.panY = 0.0;
                this.requestRedraw();
            }

            // Keep the world point under the cursor stationary while zooming
            zoomAt(canvasX, canvasY, factor) {
                const cx = this.canvas.width * 0.5;
                const cy = this.canvas.height * 0.5;
                // canvas -> current world (before zoom)
                const wx = (canvasX - cx) / this.scale - this.panX;
                const wy = (canvasY - cy) / this.scale - this.panY;
                // apply zoom
                const newScale = Math.max(0.2, Math.min(5.0, this.scale * factor));
                // solve pan' so that world point (wx,wy) maps back to (canvasX,canvasY)
                this.panX = (canvasX - cx) / newScale - wx;
                this.panY = (canvasY - cy) / newScale - wy;
                this.scale = newScale;
                this.requestRedraw();
            }

            // Attach double-click handler for reset
            initializeResetHandler() {
                this.canvas.addEventListener('dblclick', () => this.resetView());
            }

            fadeAlphaFromAge(ageSeconds) {
                if (ageSeconds <= 0) return 1.0;
                const base = Math.exp(-ageSeconds / this.config.fadeWindowSeconds);
                const shaped = Math.pow(base, this.config.fadeSharpness);
                return Math.max(this.config.minAlpha, shaped);
            }

            drawErrorEllipse(x, y, cov, confidence = 0.95) {
                if (!cov) return;
                const chi2 = 5.991; // 95% for 2D
                const a = cov[0][0], b = cov[0][1], c = cov[1][1];
                const trace = a + c;
                const det = a * c - b * b;
                const disc = Math.sqrt(Math.max(0, trace * trace - 4 * det));
                const lambda1 = (trace + disc) / 2;
                const lambda2 = (trace - disc) / 2;
                const angle = Math.atan2(lambda1 - a, b);
                const width = 2 * Math.sqrt(Math.max(0, lambda1 * chi2));
                const height = 2 * Math.sqrt(Math.max(0, lambda2 * chi2));
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(angle);
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, width, height, 0, 0, 2 * Math.PI);
                this.ctx.restore();
            }

            draw(data) {
                const { currentTime, dt, groundTruth, measurements, estimates, covariances } = data;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();
                // Apply view transform: center, then scale, then pan in world units
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(this.scale, this.scale);
                this.ctx.translate(this.panX, this.panY);

                const timeIndex = Math.floor(currentTime / dt);

                // Ground truth trail
                this.ctx.globalAlpha = 0.3;
                this.ctx.strokeStyle = '#0f0';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                for (let i = 0; i <= timeIndex && i < groundTruth.length; i++) {
                    const [x, y] = groundTruth[i];
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.stroke();

                // Historical estimates (only after init; entries can be null)
                for (let i = 0; i < timeIndex && i < estimates.length; i += 2) {
                    const est = estimates[i];
                    const cov = covariances[i];
                    if (!est || !cov) continue;
                    const t = i * dt;
                    const age = currentTime - t;
                    const a = this.fadeAlphaFromAge(age);

                    // Historical ellipses (faded) – test inclusion
                    let inside = true;
                    if (est && cov && groundTruth[i]) {
                        const dx = groundTruth[i][0] - est[0];
                        const dy = groundTruth[i][1] - est[1];
                        const Sinv = MatrixUtils.inverse2x2(cov);
                        const d2 = dx*(Sinv[0][0]*dx + Sinv[0][1]*dy) +
                                   dy*(Sinv[1][0]*dx + Sinv[1][1]*dy);
                        inside = (d2 <= 5.991);
                    }

                    this.ctx.globalAlpha = a * 0.15;
                    this.ctx.strokeStyle = inside ? 'rgba(0,255,255,1)' : 'rgba(255,80,80,1)';
                    this.ctx.fillStyle   = inside ? 'rgba(0,255,255,1)' : 'rgba(255,80,80,1)';
                    this.ctx.lineWidth = 1;
                    this.drawErrorEllipse(est[0], est[1], cov);
                    this.ctx.stroke();

                    this.ctx.globalAlpha = a * 0.05;
                    this.ctx.fill();

                    this.ctx.globalAlpha = a * 0.5;
                    this.ctx.fillStyle = '#0ff';
                    this.ctx.beginPath();
                    this.ctx.arc(est[0], est[1], 2 / this.scale, 0, 2 * Math.PI);
                    this.ctx.fill();
                }

                // Measurements (faded)
                this.ctx.globalAlpha = 1.0;
                measurements.forEach(m => {
                    if (m.time <= currentTime) {
                        const age = currentTime - m.time;
                        const a = this.fadeAlphaFromAge(age);
                        this.ctx.globalAlpha = a;
                        this.ctx.fillStyle = '#f0f';
                        this.ctx.beginPath();
                        this.ctx.arc(m.pos[0], m.pos[1], 3 / this.scale, 0, 2 * Math.PI);
                        this.ctx.fill();
                    }
                });

                // Current markers
                this.ctx.globalAlpha = 1.0;
                if (timeIndex < groundTruth.length) {
                    this.ctx.fillStyle = '#0f0';
                    this.ctx.beginPath();
                    this.ctx.arc(groundTruth[timeIndex][0], groundTruth[timeIndex][1], 6 / this.scale, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
                if (timeIndex < estimates.length) {
                    const est = estimates[timeIndex];
                    const cov = covariances[timeIndex];
                    if (est && cov) {
                        // Test if ground truth lies inside 95% ellipse
                        const pos = estimates[timeIndex];
                        const cov = covariances[timeIndex];
                        let inside = true;
                        if (pos && cov) {
                            const dx = groundTruth[timeIndex][0] - pos[0];
                            const dy = groundTruth[timeIndex][1] - pos[1];
                            const Sinv = MatrixUtils.inverse2x2(cov);
                            const d2 = dx*(Sinv[0][0]*dx + Sinv[0][1]*dy) +
                                       dy*(Sinv[1][0]*dx + Sinv[1][1]*dy);
                            inside = (d2 <= 5.991); // 95% chi-square cutoff
                        }

                        this.ctx.globalAlpha = 0.3;
                        this.ctx.strokeStyle = inside ? 'rgba(0,255,255,1)' : 'rgba(255,80,80,1)';
                        this.ctx.lineWidth = 2;
                        this.drawErrorEllipse(pos[0], pos[1], cov);
                        this.ctx.stroke();

                        this.ctx.globalAlpha = 0.05;
                        this.ctx.fillStyle = inside ? 'rgba(0,255,255,1)' : 'rgba(255,80,80,1)';
                        this.ctx.fill();

                        this.ctx.globalAlpha = 1.0;
                        this.ctx.fillStyle = '#0ff';
                        this.ctx.beginPath();
                        this.ctx.arc(est[0], est[1], 6 / this.scale, 0, 2 * Math.PI);
                        this.ctx.fill();
                    }
                }
                this.ctx.restore();
            }
        }

        // ================================
        // ERROR GRAPH VISUALIZATION ENGINE
        // ================================

        class ErrorGraphVisualization {
            constructor(canvasId, config = {}) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.config = {
                    marginLeft: 60,
                    marginRight: 30,
                    marginTop: 30,
                    marginBottom: 40,
                    ...config
                };
            }

            draw(data) {
                const { currentTime, maxTime, dt, errorHistory, confidenceHistory } = data;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();

                const plotWidth = this.canvas.width - this.config.marginLeft - this.config.marginRight;
                const plotHeight = this.canvas.height - this.config.marginTop - this.config.marginBottom;
                const plotLeft = this.config.marginLeft;
                const plotTop = this.config.marginTop;

                // Find max value for Y axis scaling
                let maxError = 0;
                errorHistory.forEach(err => {
                    if (err !== null && Number.isFinite(err)) {
                        maxError = Math.max(maxError, err);
                    }
                });
                confidenceHistory.forEach(conf => {
                    if (conf !== null && Number.isFinite(conf)) {
                        maxError = Math.max(maxError, conf);
                    }
                });
                maxError = Math.max(maxError, 50); // Minimum scale

                // Draw axes
                this.ctx.strokeStyle = '#666';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                // Y axis
                this.ctx.moveTo(plotLeft, plotTop);
                this.ctx.lineTo(plotLeft, plotTop + plotHeight);
                // X axis
                this.ctx.lineTo(plotLeft + plotWidth, plotTop + plotHeight);
                this.ctx.stroke();

                // Y axis labels
                this.ctx.fillStyle = '#aaa';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.textBaseline = 'middle';
                const yTicks = 5;
                for (let i = 0; i <= yTicks; i++) {
                    const value = (maxError * i / yTicks);
                    const y = plotTop + plotHeight - (i / yTicks) * plotHeight;
                    this.ctx.fillText(value.toFixed(0), plotLeft - 5, y);

                    // Grid lines
                    if (i > 0) {
                        this.ctx.strokeStyle = '#333';
                        this.ctx.lineWidth = 0.5;
                        this.ctx.beginPath();
                        this.ctx.moveTo(plotLeft, y);
                        this.ctx.lineTo(plotLeft + plotWidth, y);
                        this.ctx.stroke();
                    }
                }

                // X axis labels
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'top';
                const xTicks = 6;
                for (let i = 0; i <= xTicks; i++) {
                    const value = (maxTime * i / xTicks);
                    const x = plotLeft + (i / xTicks) * plotWidth;
                    this.ctx.fillText(value.toFixed(1) + 's', x, plotTop + plotHeight + 5);

                    // Grid lines
                    if (i > 0) {
                        this.ctx.strokeStyle = '#333';
                        this.ctx.lineWidth = 0.5;
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, plotTop);
                        this.ctx.lineTo(x, plotTop + plotHeight);
                        this.ctx.stroke();
                    }
                }

                // Axis labels
                this.ctx.fillStyle = '#4af';
                this.ctx.font = '14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Time (seconds)', plotLeft + plotWidth / 2, this.canvas.height - 5);

                this.ctx.save();
                this.ctx.translate(15, plotTop + plotHeight / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillText('Position Error (pixels)', 0, 0);
                this.ctx.restore();

                // Draw zones where actual error exceeds confidence bound
                this.ctx.fillStyle = 'rgba(255, 100, 100, 0.2)'; // Light red background
                for (let i = 0; i < errorHistory.length - 1; i++) {
                    const err = errorHistory[i];
                    const conf = confidenceHistory[i];
                    const nextErr = errorHistory[i + 1];
                    const nextConf = confidenceHistory[i + 1];
                    
                    if (err !== null && conf !== null && err > conf) {
                        const t1 = i * dt;
                        const t2 = (i + 1) * dt;
                        const x1 = plotLeft + (t1 / maxTime) * plotWidth;
                        const x2 = plotLeft + (t2 / maxTime) * plotWidth;
                        
                        this.ctx.fillRect(x1, plotTop, x2 - x1, plotHeight);
                    }
                }

                // Helper function to convert data coordinates to canvas coordinates
                const dataToCanvas = (t, error) => {
                    const x = plotLeft + (t / maxTime) * plotWidth;
                    const y = plotTop + plotHeight - (error / maxError) * plotHeight;
                    return [x, y];
                };

                // Draw confidence bound (95%) first (so it appears behind the error line)
                this.ctx.strokeStyle = '#fa4';
                this.ctx.lineWidth = 2;
                this.ctx.globalAlpha = 0.8;
                this.ctx.beginPath();
                let firstConfPoint = true;
                for (let i = 0; i < confidenceHistory.length; i++) {
                    const conf = confidenceHistory[i];
                    if (conf !== null && Number.isFinite(conf)) {
                        const t = i * dt;
                        const [x, y] = dataToCanvas(t, conf);
                        if (firstConfPoint) {
                            this.ctx.moveTo(x, y);
                            firstConfPoint = false;
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                }
                this.ctx.stroke();

                // Draw actual error line
                this.ctx.strokeStyle = '#f44';
                this.ctx.lineWidth = 2;
                this.ctx.globalAlpha = 1.0;
                this.ctx.beginPath();
                let firstErrorPoint = true;
                for (let i = 0; i < errorHistory.length; i++) {
                    const err = errorHistory[i];
                    if (err !== null && Number.isFinite(err)) {
                        const t = i * dt;
                        const [x, y] = dataToCanvas(t, err);
                        if (firstErrorPoint) {
                            this.ctx.moveTo(x, y);
                            firstErrorPoint = false;
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                }
                this.ctx.stroke();

                // Draw current time indicator
                const currentTimeX = plotLeft + (currentTime / maxTime) * plotWidth;
                this.ctx.strokeStyle = '#4af';
                this.ctx.lineWidth = 2;
                this.ctx.globalAlpha = 0.8;
                this.ctx.beginPath();
                this.ctx.moveTo(currentTimeX, plotTop);
                this.ctx.lineTo(currentTimeX, plotTop + plotHeight);
                this.ctx.stroke();

                this.ctx.restore();
            }
        }

        // ================================
        // STATE DISPLAY ENGINE
        // ================================

        class StateDisplayEngine {
            constructor() { this.elements = this.cacheElements(); }

            cacheElements() {
                return {
                    measurementStatus: document.getElementById('measurementStatus'),
                    stateX: document.getElementById('state-x'),
                    stateY: document.getElementById('state-y'),
                    stateVx: document.getElementById('state-vx'),
                    stateVy: document.getElementById('state-vy'),
                    stateAx: document.getElementById('state-ax'),
                    stateAy: document.getElementById('state-ay'),
                    p00: document.getElementById('p00'),
                    p01: document.getElementById('p01'),
                    p10: document.getElementById('p10'),
                    p11: document.getElementById('p11'),
                    posError: document.getElementById('pos-error'),
                    stdX: document.getElementById('std-x'),
                    stdY: document.getElementById('std-y'),
                    coverage95: document.getElementById('coverage-95'),
                    innovationX: document.getElementById('innovation-x'),
                    innovationY: document.getElementById('innovation-y'),
                    kalmanGainElements: [
                        'k00', 'k01', 'k10', 'k11', 'k20', 'k21',
                        'k30', 'k31', 'k40', 'k41', 'k50', 'k51'
                    ].map(id => ({ id, element: document.getElementById(id) }))
                };
            }

            displayMatrix(matrix, elementId) {
                const container = document.getElementById(elementId);
                if (!container) return;
                container.innerHTML = '';
                matrix.forEach(row => {
                    row.forEach(val => {
                        const cell = document.createElement('div');
                        cell.className = 'matrix-cell';
                        const num = typeof val === 'number' ? val : 0;
                        if (Math.abs(num) < 0.001 && num !== 0) cell.textContent = num.toExponential(1);
                        else if (Math.abs(num) < 0.01) cell.textContent = num.toFixed(4);
                        else cell.textContent = num.toFixed(3);
                        container.appendChild(cell);
                    });
                });
            }

            updateDisplay(filterState, groundTruth, systemMatrices, showMatrices) {
                const { state, covariance, innovation, kalmanGain, innovationCovariance, hadMeasurement, initialized, bootstrapCount, bootstrapNeeded } = filterState;

                // Measurement/Status banner
                if (!initialized) {
                    this.elements.measurementStatus.textContent = `Bootstrapping (${bootstrapCount}/${bootstrapNeeded})`;
                    this.elements.measurementStatus.className = 'measurement-indicator bootstrapping';
                } else if (hadMeasurement) {
                    this.elements.measurementStatus.textContent = 'Measurement Update';
                    this.elements.measurementStatus.className = 'measurement-indicator';
                } else {
                    this.elements.measurementStatus.textContent = 'Prediction Only';
                    this.elements.measurementStatus.className = 'measurement-indicator no-measurement';
                }

                // State vector
                const setVal = (el, val) => {
                    if (val === null || val === undefined) { el.textContent = '--'; el.classList.add('inactive'); }
                    else { el.textContent = val.toFixed(2); el.classList.remove('inactive'); }
                };

                if (!initialized || !state) {
                    [this.elements.stateX, this.elements.stateY, this.elements.stateVx, this.elements.stateVy, this.elements.stateAx, this.elements.stateAy].forEach(el => {
                        el.textContent = '--'; el.classList.add('inactive');
                    });
                    [this.elements.p00, this.elements.p01, this.elements.p10, this.elements.p11, this.elements.posError, this.elements.stdX, this.elements.stdY].forEach(el => {
                        el.textContent = '--'; el.classList.add('inactive');
                    });
                    // Innovation / gain placeholders
                    this.updateInnovationAndGain(null, null, true);
                } else {
                    setVal(this.elements.stateX, state[0]);
                    setVal(this.elements.stateY, state[1]);
                    setVal(this.elements.stateVx, state[2]);
                    setVal(this.elements.stateVy, state[3]);
                    setVal(this.elements.stateAx, state[4]);
                    setVal(this.elements.stateAy, state[5]);

                    // Position covariance & metrics
                    if (covariance) {
                        setVal(this.elements.p00, covariance[0][0]);
                        setVal(this.elements.p01, covariance[0][1]);
                        setVal(this.elements.p10, covariance[1][0]);
                        setVal(this.elements.p11, covariance[1][1]);

                        const posError = Math.sqrt(Math.pow(state[0] - groundTruth[0], 2) + Math.pow(state[1] - groundTruth[1], 2));
                        setVal(this.elements.posError, posError);
                        setVal(this.elements.stdX, Math.sqrt(covariance[0][0]));
                        setVal(this.elements.stdY, Math.sqrt(covariance[1][1]));
                        // Coverage display
                        if (typeof filterState.coveragePct === 'number') {
                            this.elements.coverage95.textContent = (filterState.coveragePct * 100).toFixed(1) + '%';
                            this.elements.coverage95.classList.remove('inactive');
                        } else { this.elements.coverage95.textContent = '--'; }
                    }

                    // Innovation / gain
                    this.updateInnovationAndGain(innovation, kalmanGain, !hadMeasurement);
                }

                if (showMatrices && systemMatrices) {
                    this.displayMatrix(systemMatrices.F, 'matrix-F');
                    this.displayMatrix(systemMatrices.H, 'matrix-H');
                    this.displayMatrix(systemMatrices.Q, 'matrix-Q');
                    this.displayMatrix(systemMatrices.R, 'matrix-R');
                    if (covariance) this.displayMatrix(filterState.fullCovariance, 'matrix-P-full');
                    else document.getElementById('matrix-P-full').innerHTML = '<div class="matrix-cell inactive">Not initialized</div>';

                    if (innovationCovariance) this.displayMatrix(innovationCovariance, 'matrix-S');
                    else document.getElementById('matrix-S').innerHTML = '<div class="matrix-cell inactive">Not computed</div>';
                }
            }

            updateInnovationAndGain(innovation, kalmanGain, inactive) {
                if (innovation) {
                    this.elements.innovationX.textContent = innovation[0].toFixed(2);
                    this.elements.innovationY.textContent = innovation[1].toFixed(2);
                    if (inactive) { this.elements.innovationX.classList.add('inactive'); this.elements.innovationY.classList.add('inactive'); }
                    else { this.elements.innovationX.classList.remove('inactive'); this.elements.innovationY.classList.remove('inactive'); }
                } else {
                    this.elements.innovationX.textContent = '--';
                    this.elements.innovationY.textContent = '--';
                    this.elements.innovationX.classList.add('inactive');
                    this.elements.innovationY.classList.add('inactive');
                }

                if (kalmanGain) {
                    this.elements.kalmanGainElements.forEach(({ element }, index) => {
                        const row = Math.floor(index / 2), col = index % 2;
                        element.textContent = kalmanGain[row][col].toFixed(3);
                        if (inactive) element.classList.add('inactive'); else element.classList.remove('inactive');
                    });
                } else {
                    this.elements.kalmanGainElements.forEach(({ element }) => {
                        element.textContent = '--'; element.classList.add('inactive');
                    });
                }
            }
        }

        // ================================
        // UI CONTROLLER
        // ================================

        class UIController {
            constructor(simulationController) {
                this.sim = simulationController;
                this.initializeControls();
            }

            initializeControls() {
                document.getElementById('trajectorySelect').addEventListener('change', (e) => {
                    this.sim.setTrajectoryType(e.target.value);
                });

                const timeSlider = document.getElementById('timeSlider');
                const timeValue = document.getElementById('timeValue');
                timeSlider.max = this.sim.config.maxTime / this.sim.config.dt;

                timeSlider.addEventListener('input', (e) => {
                    this.sim.setTime(e.target.value * this.sim.config.dt);
                    timeValue.textContent = this.sim.currentTime.toFixed(2) + 's';
                });

                document.getElementById('measurementNoise').addEventListener('input', (e) => {
                    document.getElementById('measurementNoiseValue').textContent = e.target.value;
                    this.sim.updateNoiseParams();
                });

                document.getElementById('processNoise').addEventListener('input', (e) => {
                    document.getElementById('processNoiseValue').textContent = e.target.value;
                    this.sim.updateNoiseParams();
                });

                document.getElementById('playBtn').addEventListener('click', () => this.sim.togglePlay());
                document.getElementById('stepBtn').addEventListener('click', () => this.sim.step());
                document.getElementById('resetBtn').addEventListener('click', () => this.sim.reset());

                document.getElementById('toggleMatrices').addEventListener('click', () => {
                    const section = document.getElementById('matricesSection');
                    const toggle = document.getElementById('toggleMatrices');
                    const isVisible = section.classList.toggle('visible');
                    toggle.textContent = isVisible ? 'Hide System Matrices & Equations ▲' : 'Show System Matrices & Equations ▼';
                    this.sim.setMatrixVisibility(isVisible);
                });
            }

            updateTimeDisplay() {
                document.getElementById('timeSlider').value = this.sim.currentTime / this.sim.config.dt;
                document.getElementById('timeValue').textContent = this.sim.currentTime.toFixed(2) + 's';
            }
        }

        // ================================
        // MAIN SIMULATION CONTROLLER
        // ================================

        class SimulationController {
            constructor(config = {}) {
                this.config = {
                    maxTime: 30,
                    dt: 0.05,
                    measurementRate: 0.1,
                    bootstrapMeasurements: 3,   // <– how many measurements to wait
                    ...config
                };

                this.trajectoryType = 'constaccel_line';
                this.trajectoryGenerator = this.createTrajectoryGenerator();
                this.filter = new KalmanFilter2D({
                    dt: this.config.dt,
                    measurementNoise: 5,
                    processNoise: 1
                });

                this.visualization = new VisualizationEngine('canvas');
                this.errorGraph = new ErrorGraphVisualization('errorGraph');
                this.stateDisplay = new StateDisplayEngine();

                this.currentTime = 0;
                this.playing = false;
                this.showMatrices = false;

                this.groundTruth = [];
                this.measurements = [];
                this.estimates = [];
                this.covariances = [];
                this.filterStates = [];
                this.errorHistory = [];
                this.confidenceHistory = [];

                this.generateData();
            }

            createFilter() {
                return new KalmanFilter2D({
                    dt: this.config.dt,
                    measurementNoise: this.getMeasurementNoise(),
                    processNoise: this.getProcessNoise()
                });
            }

            createTrajectoryGenerator() {
                const config = { maxTime: this.config.maxTime, scale: 150 };
                switch (this.trajectoryType) {
                    case 'minjerk':
                        return new MinimumJerkGenerator(config);
                    case 'lissajous':
                        return new LissajousGenerator(config);
                    case 'clothoid':
                        return new ClothoidGenerator(config);
                    case 'rfsmooth':
                        return new RandomFourierSmoothGenerator(config);
                    case 'constaccel_bezier':
                        return new ConstAccelBezierGenerator(config);
                    case 'constaccel_line':
                        return new ConstAccelLineGenerator(config);
                    case 'figure8': return new Figure8Generator(config);
                    case 'circle': return new CircleGenerator(config);
                    case 'constantvelocity': return new ConstantVelocityGenerator(config);
                    case 'constantacceleration': return new ConstantAccelerationGenerator(config);
                    case 'sinewave': return new SineWaveGenerator(config);
                    case 'parabolic': return new ParabolicGenerator(config);
                    case 'square': return new SquareGenerator(config);
                    case 'spiral': return new SpiralGenerator(config);
                    case 'heart': return new HeartGenerator(config);
                    case 'star': return new StarGenerator(config);
                    case 'infinity': return new InfinityGenerator(config);
                    case 'stepfunction': return new StepFunctionGenerator(config);
                    case 'stopandgo': return new StopAndGoGenerator(config);
                    case 'randomwalk': return new RandomWalkGenerator(config);
                    default: return new Figure8Generator(config);
                }
            }

            getMeasurementNoise() { return parseFloat(document.getElementById('measurementNoise').value); }
            getProcessNoise() { return parseFloat(document.getElementById('processNoise').value); }

            // Helper to build an initial covariance (position from R, big uncertainty elsewhere)
            buildInitialCovariance(measVar) {
                const P = MatrixUtils.identity(6).map(row => row.map(() => 0));
                P[0][0] = measVar * 4;  // position x
                P[1][1] = measVar * 4;  // position y
                P[2][2] = 1000;         // velocity x
                P[3][3] = 1000;         // velocity y
                P[4][4] = 10000;        // acceleration x
                P[5][5] = 10000;        // acceleration y
                return P;
            }

            // Initialize using last 3 measurements (central/second differences)
            initializeFromBuffer(buffer) {
                // buffer has entries: {time, pos:[x,y]}
                const n = buffer.length;
                const m1 = buffer[n-3], m2 = buffer[n-2], m3 = buffer[n-1];

                const x3 = (m1.pos[0] + m2.pos[0] + m3.pos[0]) / 3;
                const y3 = (m1.pos[1] + m2.pos[1] + m3.pos[1]) / 3;
                const vx = 0;
                const vy = 0;
                const ax = 0;
                const ay = 0;

                const x0 = [[x3],[y3],[vx],[vy],[ax],[ay]];
                const r = this.getMeasurementNoise();
                const P0 = this.buildInitialCovariance(r*r);
                this.filter.setInitialState(x0, P0);
            }

            generateData() {
                this.groundTruth = [];
                this.measurements = [];
                this.estimates = [];
                this.covariances = [];
                this.filterStates = [];
                this.errorHistory = [];
                this.confidenceHistory = [];

                this.filter = this.createFilter();
                const measurementNoise = this.getMeasurementNoise();
                let lastMeasurementTime = -Infinity;

                let lastInnovation = null;
                let lastKalmanGain = null;
                let lastInnovationCovariance = null;
                // Coverage counters (cumulative over time)
                let coverageHits = 0;
                let coverageTotal = 0;

                // Bootstrapping buffer
                const bootstrapNeeded = this.config.bootstrapMeasurements;
                const buffer = [];

                for (let t = 0; t <= this.config.maxTime + 1e-9; t += this.config.dt) {
                    const truth = this.trajectoryGenerator.generatePosition(t);
                    this.groundTruth.push(truth);

                    // Decide if a measurement arrives at this time
                    let hadMeasurement = false;
                    if (t - lastMeasurementTime >= this.config.measurementRate - this.config.dt/2) {
                        const measurement = NoiseUtils.addGaussianNoise(truth, measurementNoise);
                        this.measurements.push({ time: t, pos: measurement });
                        lastMeasurementTime = t;
                        hadMeasurement = true;

                        // Accumulate for bootstrap
                        buffer.push({ time: t, pos: measurement });
                        if (!this.filter.initialized && buffer.length >= bootstrapNeeded) {
                            this.initializeFromBuffer(buffer);
                        }
                    }

                    // Run filter only after initialization
                    if (this.filter.initialized) {
                        this.filter.predict();
                        if (hadMeasurement) {
                            this.filter.update([[this.measurements[this.measurements.length-1].pos[0]], [this.measurements[this.measurements.length-1].pos[1]]]);
                        }

                        if (this.filter.lastInnovation) lastInnovation = [...this.filter.lastInnovation.map(row => row[0])];
                        if (this.filter.lastKalmanGain) lastKalmanGain = this.filter.lastKalmanGain.map(row => [...row]);
                        if (this.filter.lastInnovationCovariance) lastInnovationCovariance = this.filter.lastInnovationCovariance.map(row => [...row]);

                        const position = this.filter.getPosition();
                        const covPos = this.filter.getPositionCovariance();
                        this.estimates.push(position);
                        this.covariances.push(covPos);

                        // Calculate position error and 95% confidence bound
                        if (position && covPos) {
                            // Position error (Euclidean distance)
                            const error = Math.sqrt(Math.pow(truth[0] - position[0], 2) + Math.pow(truth[1] - position[1], 2));
                            this.errorHistory.push(error);

                            // 95% confidence bound (major axis of confidence ellipse)
                            const a = covPos[0][0], b = covPos[0][1], c = covPos[1][1];
                            const trace = a + c;
                            const det = a * c - b * b;
                            const disc = Math.sqrt(Math.max(0, trace * trace - 4 * det));
                            const maxEigenvalue = (trace + disc) / 2;
                            const confidence95 = Math.sqrt(Math.max(0, maxEigenvalue * 5.991)); // chi2(2,0.95) = 5.991
                            this.confidenceHistory.push(confidence95);
                        } else {
                            this.errorHistory.push(null);
                            this.confidenceHistory.push(null);
                        }

                        // Update coverage only after filter is initialized
                        // (inside 95% ellipse => r^T S^{-1} r <= 5.991)
                        if (this.filter.initialized && position && covPos) {
                            const r0 = truth[0] - position[0];
                            const r1 = truth[1] - position[1];
                            const Sinv = MatrixUtils.inverse2x2(covPos);
                            const d2 = r0 * (Sinv[0][0]*r0 + Sinv[0][1]*r1) + r1 * (Sinv[1][0]*r0 + Sinv[1][1]*r1);
                            if (Number.isFinite(d2)) {
                                coverageTotal += 1;
                                if (d2 <= 5.991) coverageHits += 1;
                            }
                        }
                    } else {
                        // Not initialized yet: no estimate/covariance
                        this.estimates.push(null);
                        this.covariances.push(null);
                        this.errorHistory.push(null);
                        this.confidenceHistory.push(null);
                    }

                    // Store state snapshot for the panel
                    let stateArray = null, posCov2x2 = null, fullP = null;
                    if (this.filter.initialized) {
                        stateArray = [...this.filter.getState().map(row => row[0])];
                        fullP = this.filter.covariance.map(row => [...row]);
                        posCov2x2 = MatrixUtils.extractSubmatrix(this.filter.covariance, 0, 1, 0, 1);
                    }

                    this.filterStates.push({
                        state: stateArray,
                        covariance: posCov2x2,
                        fullCovariance: fullP,
                        innovation: lastInnovation,
                        kalmanGain: lastKalmanGain,
                        innovationCovariance: lastInnovationCovariance,
                        hadMeasurement: hadMeasurement,
                        initialized: this.filter.initialized,
                        bootstrapCount: Math.min(buffer.length, bootstrapNeeded),
                        bootstrapNeeded: bootstrapNeeded,
                        coveragePct: coverageTotal > 0 ? (coverageHits / coverageTotal) : null
                    });
                }

                // Update fixed, whole-duration coverage display in Controls
                const totalEl = document.getElementById('total-coverage-95');
                if (totalEl) totalEl.textContent = coverageTotal > 0 ? ((coverageHits / coverageTotal) * 100).toFixed(1) + '%' : '--';
            }

            updateNoiseParams() {
                if (this.filter.updateNoise) {
                    this.filter.updateNoise(this.getMeasurementNoise(), this.getProcessNoise());
                }
                this.generateData();
                this.draw();
            }

            setTime(newTime) {
                this.currentTime = Math.max(0, Math.min(newTime, this.config.maxTime));
                this.draw();
            }

            togglePlay() { this.playing = !this.playing; }

            step() {
                this.playing = false;
                this.currentTime += this.config.dt;
                if (this.currentTime > this.config.maxTime) this.currentTime = 0;
                this.ui.updateTimeDisplay();
                this.draw();
            }

            reset() {
                this.playing = false;
                this.currentTime = 0;
                this.generateData();
                this.ui.updateTimeDisplay();
                this.draw();
            }

            setMatrixVisibility(visible) { this.showMatrices = visible; this.draw(); }

            setTrajectoryType(trajectoryType) {
                this.trajectoryType = trajectoryType;
                this.trajectoryGenerator = this.createTrajectoryGenerator();
                this.generateData();
                this.currentTime = 0;
                if (this.ui) this.ui.updateTimeDisplay();
                this.draw();
            }

            draw() {
                this.visualization.draw({
                    currentTime: this.currentTime,
                    dt: this.config.dt,
                    groundTruth: this.groundTruth,
                    measurements: this.measurements,
                    estimates: this.estimates,
                    covariances: this.covariances
                });

                this.errorGraph.draw({
                    currentTime: this.currentTime,
                    maxTime: this.config.maxTime,
                    dt: this.config.dt,
                    errorHistory: this.errorHistory,
                    confidenceHistory: this.confidenceHistory
                });

                const timeIndex = Math.floor(this.currentTime / this.config.dt);
                if (timeIndex < this.filterStates.length) {
                    this.stateDisplay.updateDisplay(
                        this.filterStates[timeIndex],
                        this.groundTruth[timeIndex],
                        this.filter.getSystemMatrices(),
                        this.showMatrices
                    );
                }
            }

            animate() {
                if (this.playing) {
                    this.currentTime += this.config.dt;
                    if (this.currentTime > this.config.maxTime) this.currentTime = 0;
                    if (this.ui) this.ui.updateTimeDisplay();
                    this.draw();
                }
                requestAnimationFrame(() => this.animate());
            }

            start() {
                this.ui = new UIController(this);
                this.draw();
                this.visualization.initializeResetHandler();
                this.visualization.setOnViewChange(() => this.draw()); // redraw even when paused
                this.animate();
            }
        }

        // ================================
        // APPLICATION STARTUP
        // ================================

        function startApplication() {
            const config = { maxTime: 30, dt: 0.05, measurementRate: 0.1 };
            const simulation = new SimulationController(config);
            simulation.start();
        }
        startApplication();
    </script>
</body>
</html>