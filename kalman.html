<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Kalman Filter Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .main-container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
            align-items: flex-start;
        }
        .viz-container {
            flex: 1;
        }
        #canvas {
            border: 1px solid #444;
            background: #0a0a0a;
            display: block;
            margin: 20px auto;
        }
        .controls {
            max-width: 800px;
            margin: 0 auto 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        .system-matrices {
            max-width: 1200px;
            margin: 0 auto 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        .state-panel {
            width: 350px;
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Matrix Display Styles */
        .matrix-container {
            display: inline-block;
            position: relative;
            margin: 10px;
            font-family: 'Courier New', monospace;
        }

        .matrix-brackets {
            position: relative;
            display: inline-block;
        }

        .matrix-brackets::before,
        .matrix-brackets::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 8px;
            border: 2px solid #4af;
            border-left: none;
            border-right: none;
        }

        .matrix-brackets::before {
            left: -10px;
            border-left: 2px solid #4af;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .matrix-brackets::after {
            right: -10px;
            border-right: 2px solid #4af;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        .matrix-grid {
            display: grid;
            gap: 6px 10px;
            padding: 8px 15px;
            align-items: center;
            justify-items: center;
        }

        .matrix-2x2 { grid-template-columns: repeat(2, 1fr); }
        .matrix-2x6 { grid-template-columns: repeat(6, 1fr); }
        .matrix-6x2 { grid-template-columns: repeat(2, 1fr); }
        .matrix-6x6 { grid-template-columns: repeat(6, 1fr); }

        .matrix-cell {
            font-size: 10px;
            color: #0ff;
            text-align: center;
            min-width: 42px;
            white-space: nowrap;
        }

        .matrix-cell.inactive {
            color: #666;
        }

        .matrix-title {
            color: #4af;
            font-size: 13px;
            margin-bottom: 5px;
            text-align: center;
            font-family: Arial, sans-serif;
        }

        .matrices-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 25px;
            margin-top: 15px;
        }

        .matrix-display {
            text-align: center;
            background: #1a1a1a;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #333;
        }

        h2[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            border: 1px solid #4af;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            line-height: 1.4;
            width: 280px;
            z-index: 100;
            pointer-events: none;
            margin-top: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            font-weight: normal;
            font-family: Arial, sans-serif;
        }
        h2[data-tooltip] {
            position: relative;
        }
        .state-panel h2:hover::after {
            content: "The Kalman filter optimally combines noisy measurements with a motion model to estimate the true state. It balances trust between predictions and measurements based on their relative uncertainties.";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            border: 1px solid #4af;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            line-height: 1.4;
            width: 280px;
            z-index: 100;
            pointer-events: none;
            margin-top: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            font-weight: normal;
            font-family: Arial, sans-serif;
        }
        .state-section {
            margin-bottom: 20px;
        }
        .state-section h3 {
            color: #4af;
            margin: 0 0 10px 0;
            font-size: 14px;
            font-family: Arial, sans-serif;
            cursor: help;
            position: relative;
        }
        .state-section h3:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 0;
            background: #1a1a1a;
            border: 1px solid #4af;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            line-height: 1.4;
            width: 280px;
            z-index: 100;
            pointer-events: none;
            margin-bottom: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            font-weight: normal;
        }
        .state-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        .state-label {
            color: #aaa;
            position: relative;
            cursor: help;
        }
        .state-label:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 0;
            background: #1a1a1a;
            border: 1px solid #4af;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            line-height: 1.4;
            width: 250px;
            z-index: 100;
            pointer-events: none;
            margin-bottom: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        .state-value {
            color: #0ff;
            text-align: right;
        }
        .state-value.inactive {
            color: #666;
        }
        .slider-container label {
            cursor: help;
            position: relative;
        }
        .slider-container label:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 0;
            background: #1a1a1a;
            border: 1px solid #4af;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            line-height: 1.4;
            width: 300px;
            z-index: 100;
            pointer-events: none;
            margin-bottom: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        .measurement-indicator {
            padding: 5px;
            margin: 10px 0;
            background: #3a2a4a;
            border-radius: 4px;
            text-align: center;
            color: #f0f;
        }
        .no-measurement {
            background: #2a3a3a;
            color: #888;
        }
        .slider-container {
            margin: 15px 0;
        }
        label {
            display: inline-block;
            width: 200px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 300px;
            vertical-align: middle;
        }
        .value {
            display: inline-block;
            width: 60px;
            text-align: right;
            color: #4af;
        }
        .legend {
            margin: 20px auto 10px;
            max-width: 1400px;
            display: flex;
            justify-content: center;
            gap: 30px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 20px;
            height: 3px;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            background: #4af;
            border: none;
            border-radius: 4px;
            color: #000;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: #6cf;
        }
        .toggle-section {
            color: #4af;
            cursor: pointer;
            padding: 10px;
            background: #333;
            border-radius: 4px;
            text-align: center;
            margin: 15px 0;
            user-select: none;
        }
        .toggle-section:hover {
            background: #444;
        }
        .matrices-section {
            display: none;
            margin-top: 15px;
        }
        .matrices-section.visible {
            display: block;
        }
        .equation-section {
            margin: 15px 0;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 4px;
            border-left: 3px solid #4af;
        }
        .eq-label {
            color: #4af;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .equation-line {
            font-family: 'Courier New', monospace;
            color: #0ff;
            margin: 4px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">2D Kalman Filter - Multi-Shape Tracking</h1>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #0f0;"></div>
            <span>Ground Truth</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f0f;"></div>
            <span>Measurements</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0ff; width: 6px; height: 6px; border-radius: 3px;"></div>
            <span>Kalman Estimates</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(0,255,255,0.3);"></div>
            <span>95% Confidence</span>
        </div>
    </div>

    <div class="main-container">
        <div class="viz-container">
            <canvas id="canvas" width="800" height="600"></canvas>

            <div class="controls">
                <div class="slider-container">
                    <label data-tooltip="Select the trajectory shape for the object to follow. Different shapes test various aspects of the filter's performance.">Trajectory Shape:</label>
                    <select id="trajectorySelect" style="width: 220px; padding: 4px; background: #333; color: #fff; border: 1px solid #666; border-radius: 4px;">
                        <option value="figure8">Figure-8</option>
                        <option value="circle">Circle</option>
                        <option value="constantvelocity">Constant Velocity Line</option>
                        <option value="constantacceleration">Constant Acceleration Line</option>
                        <option value="sinewave">Sine Wave</option>
                        <option value="parabolic">Parabolic Arc</option>
                        <option value="square">Square</option>
                        <option value="spiral">Spiral</option>
                        <option value="heart">Heart</option>
                        <option value="star">Star</option>
                        <option value="infinity">Infinity (∞)</option>
                        <option value="stepfunction">Step Function</option>
                        <option value="stopandgo">Stop and Go</option>
                        <option value="randomwalk">Random Walk</option>
                    </select>
                </div>

                <div class="slider-container">
                    <label data-tooltip="Current simulation time. The filter runs at 20Hz (every 0.05s) while measurements arrive at 10Hz (every 0.1s). The object completes multiple trajectory patterns over 30 seconds.">Time:</label>
                    <input type="range" id="timeSlider" min="0" max="100" value="0" step="1">
                    <span class="value" id="timeValue">0.00s</span>
                </div>

                <div class="slider-container">
                    <label data-tooltip="Standard deviation of noise added to position measurements. Higher values make measurements less reliable, causing the filter to trust its model more.">Measurement Noise (σ):</label>
                    <input type="range" id="measurementNoise" min="1" max="50" value="15" step="1">
                    <span class="value" id="measurementNoiseValue">15</span>
                </div>

                <div class="slider-container">
                    <label data-tooltip="Uncertainty in the motion model. Higher values mean the filter expects more random accelerations, making it trust measurements more and predictions less.">Process Noise:</label>
                    <input type="range" id="processNoise" min="0.1" max="5" value="1" step="0.1">
                    <span class="value" id="processNoiseValue">1.0</span>
                </div>

                <div style="text-align: center; margin-top: 20px;">
                    <button id="playBtn">Play/Pause</button>
                    <button id="stepBtn">Step</button>
                    <button id="resetBtn">Reset</button>
                </div>
            </div>
        </div>

        <div class="state-panel">
            <h2 style="color: #4af; text-align: center; margin-top: 0; cursor: help;" data-tooltip="The Kalman filter optimally combines noisy measurements with a motion model to estimate the true state. It balances trust between predictions and measurements based on their relative uncertainties.">Filter State</h2>

            <div id="measurementStatus" class="measurement-indicator no-measurement">
                No Measurement
            </div>

            <div class="state-section">
                <h3 data-tooltip="The filter's current estimate of the object's state, including position, velocity, and acceleration in both X and Y dimensions.">State Vector x̂</h3>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated X position of the object in pixels from center">Position X:</span>
                    <span class="state-value" id="state-x">0.00</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated Y position of the object in pixels from center">Position Y:</span>
                    <span class="state-value" id="state-y">0.00</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated velocity in X direction (pixels per second)">Velocity X:</span>
                    <span class="state-value" id="state-vx">0.00</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated velocity in Y direction (pixels per second)">Velocity Y:</span>
                    <span class="state-value" id="state-vy">0.00</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated acceleration in X direction (pixels per second²)">Accel X:</span>
                    <span class="state-value" id="state-ax">0.00</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Estimated acceleration in Y direction (pixels per second²)">Accel Y:</span>
                    <span class="state-value" id="state-ay">0.00</span>
                </div>
            </div>

            <div class="state-section">
                <h3 data-tooltip="The covariance matrix quantifies the uncertainty in position estimates. Larger values mean less confidence. The ellipse visualization is derived from this matrix.">Position Covariance P</h3>
                <div class="matrix-container">
                    <div class="matrix-brackets">
                        <div class="matrix-grid matrix-2x2">
                            <div class="matrix-cell" id="p00">0.00</div>
                            <div class="matrix-cell" id="p01">0.00</div>
                            <div class="matrix-cell" id="p10">0.00</div>
                            <div class="matrix-cell" id="p11">0.00</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="state-section">
                <h3 data-tooltip="Metrics comparing the filter's estimates to ground truth and showing the filter's confidence levels.">Error Metrics</h3>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Euclidean distance between the filter estimate and ground truth position">Position Error:</span>
                    <span class="state-value" id="pos-error">0.00</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Square root of X variance from covariance matrix. Represents 1-sigma uncertainty in X direction">Std Dev X:</span>
                    <span class="state-value" id="std-x">0.00</span>
                </div>
                <div class="state-row">
                    <span class="state-label" data-tooltip="Square root of Y variance from covariance matrix. Represents 1-sigma uncertainty in Y direction">Std Dev Y:</span>
                    <span class="state-value" id="std-y">0.00</span>
                </div>
            </div>

            <div class="state-section">
                <h3 data-tooltip="The innovation (or residual) is the difference between what was measured and what the filter predicted. Large innovations indicate surprising measurements.">Innovation (Residual)</h3>
                <div class="matrix-container">
                    <div class="matrix-brackets">
                        <div class="matrix-grid matrix-2x1" style="grid-template-columns: 1fr;">
                            <div class="matrix-cell" id="innovation-x">--</div>
                            <div class="matrix-cell" id="innovation-y">--</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="state-section">
                <h3 data-tooltip="The Kalman gain determines how much the filter trusts new measurements versus its predictions. Higher values mean more trust in measurements, lower values mean more trust in the model.">Kalman Gain K</h3>
                <div class="matrix-container">
                    <div class="matrix-brackets">
                        <div class="matrix-grid matrix-6x2">
                            <div class="matrix-cell" id="k00">--</div>
                            <div class="matrix-cell" id="k01">--</div>
                            <div class="matrix-cell" id="k10">--</div>
                            <div class="matrix-cell" id="k11">--</div>
                            <div class="matrix-cell" id="k20">--</div>
                            <div class="matrix-cell" id="k21">--</div>
                            <div class="matrix-cell" id="k30">--</div>
                            <div class="matrix-cell" id="k31">--</div>
                            <div class="matrix-cell" id="k40">--</div>
                            <div class="matrix-cell" id="k41">--</div>
                            <div class="matrix-cell" id="k50">--</div>
                            <div class="matrix-cell" id="k51">--</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- System Matrices Section -->
    <div class="system-matrices">
        <div class="toggle-section" id="toggleMatrices">
            Show System Matrices & Equations ▼
        </div>

        <div class="matrices-section" id="matricesSection">
            <div class="matrices-grid">
                <div class="matrix-display">
                    <div class="matrix-title">State Transition F (6×6)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">Predicts next state from current state</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-F" class="matrix-grid matrix-6x6"></div>
                        </div>
                    </div>
                </div>

                <div class="matrix-display">
                    <div class="matrix-title">Measurement H (2×6)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">Maps state to expected measurement (extracts position)</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-H" class="matrix-grid matrix-2x6"></div>
                        </div>
                    </div>
                </div>

                <div class="matrix-display">
                    <div class="matrix-title">Process Noise Q (6×6)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">Uncertainty added during prediction</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-Q" class="matrix-grid matrix-6x6"></div>
                        </div>
                    </div>
                </div>

                <div class="matrix-display">
                    <div class="matrix-title">Measurement Noise R (2×2)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">Expected measurement uncertainty</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-R" class="matrix-grid matrix-2x2"></div>
                        </div>
                    </div>
                </div>

                <div class="matrix-display">
                    <div class="matrix-title">Full Covariance P (6×6)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">Uncertainty in all state variables</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-P-full" class="matrix-grid matrix-6x6"></div>
                        </div>
                    </div>
                </div>

                <div class="matrix-display">
                    <div class="matrix-title">Innovation Covariance S (2×2)</div>
                    <div style="font-size: 9px; color: #888; margin-bottom: 8px;">S = H×P×H<sup>T</sup> + R (measurement prediction uncertainty)</div>
                    <div class="matrix-container">
                        <div class="matrix-brackets">
                            <div id="matrix-S" class="matrix-grid matrix-2x2"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="state-section">
                <h3 data-tooltip="The mathematical operations performed during prediction and update steps">Filter Equations</h3>

                <div class="equation-section">
                    <div class="eq-label">Prediction Step (every 0.05s):</div>
                    <div class="equation-line">x̂ₖ₊₁|ₖ = F × x̂ₖ|ₖ</div>
                    <div class="equation-line">Pₖ₊₁|ₖ = F × Pₖ|ₖ × F<sup>T</sup> + Q</div>
                </div>

                <div class="equation-section" id="updateEquations">
                    <div class="eq-label">Update Step (when measurement arrives):</div>
                    <div class="equation-line">yₖ = zₖ - H × x̂ₖ|ₖ₋₁ (innovation)</div>
                    <div class="equation-line">Sₖ = H × Pₖ|ₖ₋₁ × H<sup>T</sup> + R</div>
                    <div class="equation-line">Kₖ = Pₖ|ₖ₋₁ × H<sup>T</sup> × Sₖ⁻¹</div>
                    <div class="equation-line">x̂ₖ|ₖ = x̂ₖ|ₖ₋₁ + Kₖ × yₖ</div>
                    <div class="equation-line">Pₖ|ₖ = (I - Kₖ × H) × Pₖ|ₖ₋₁</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ================================
        // UTILITY MODULES
        // ================================

        /**
         * Matrix utility functions - completely modular
         */
        class MatrixUtils {
            static multiply(A, B) {
                const m = A.length, n = A[0].length, p = B[0].length;
                const C = Array(m).fill().map(() => Array(p).fill(0));
                for (let i = 0; i < m; i++) {
                    for (let j = 0; j < p; j++) {
                        for (let k = 0; k < n; k++) {
                            C[i][j] += A[i][k] * B[k][j];
                        }
                    }
                }
                return C;
            }

            static transpose(A) {
                return A[0].map((_, i) => A.map(row => row[i]));
            }

            static add(A, B) {
                return A.map((row, i) => row.map((val, j) => val + B[i][j]));
            }

            static subtract(A, B) {
                return A.map((row, i) => row.map((val, j) => val - B[i][j]));
            }

            static inverse2x2(A) {
                const det = A[0][0] * A[1][1] - A[0][1] * A[1][0];
                return [
                    [A[1][1] / det, -A[0][1] / det],
                    [-A[1][0] / det, A[0][0] / det]
                ];
            }

            static identity(n) {
                return Array(n).fill().map((_, i) =>
                    Array(n).fill().map((_, j) => i === j ? 1 : 0)
                );
            }

            static extractSubmatrix(matrix, startRow, endRow, startCol, endCol) {
                return matrix.slice(startRow, endRow + 1)
                    .map(row => row.slice(startCol, endCol + 1));
            }
        }

        /**
         * Noise generation utilities
         */
        class NoiseUtils {
            static gaussian(sigma = 1.0) {
                // Box-Muller transform
                const u = Math.random();
                const v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v) * sigma;
            }

            static addGaussianNoise(position, sigma) {
                return [
                    position[0] + this.gaussian(sigma),
                    position[1] + this.gaussian(sigma)
                ];
            }
        }

        // ================================
        // DATA GENERATOR INTERFACES
        // ================================

        /**
         * Base class for trajectory generators
         * Extend this to create new trajectory types
         */
        class TrajectoryGenerator {
            constructor(config = {}) {
                this.config = {
                    maxTime: 30,
                    scale: 150,
                    ...config
                };
            }

            /**
             * Generate position at time t
             * @param {number} t - Time in seconds
             * @returns {[number, number]} - [x, y] position
             */
            generatePosition(t) {
                throw new Error('generatePosition must be implemented by subclass');
            }

            /**
             * Get trajectory name for display
             */
            getName() {
                return 'Generic Trajectory';
            }
        }

        /**
         * Figure-8 trajectory generator
         */
        class Figure8Generator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                // Complete 3 figure-8s over maxTime
                const phase = t * 3 * 2 * Math.PI / maxTime;
                const x = scale * Math.sin(phase);
                const y = scale * Math.sin(phase) * Math.cos(phase);
                return [x, y];
            }

            getName() {
                return 'Figure-8';
            }
        }

        /**
         * Circle trajectory generator - example of easy swapping
         */
        class CircleGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const phase = t * 2 * Math.PI / (maxTime / 3); // 3 circles in maxTime
                const x = scale * Math.cos(phase);
                const y = scale * Math.sin(phase);
                return [x, y];
            }

            getName() {
                return 'Circle';
            }
        }

        /**
         * Square trajectory generator - tests sharp corners
         */
        class SquareGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const cycleTime = maxTime / 3; // 3 squares in maxTime
                const phase = (t % cycleTime) / cycleTime; // 0 to 1 for one cycle

                if (phase < 0.25) {
                    // Top edge: left to right
                    const progress = phase / 0.25;
                    return [scale * (progress * 2 - 1), scale];
                } else if (phase < 0.5) {
                    // Right edge: top to bottom
                    const progress = (phase - 0.25) / 0.25;
                    return [scale, scale * (1 - progress * 2)];
                } else if (phase < 0.75) {
                    // Bottom edge: right to left
                    const progress = (phase - 0.5) / 0.25;
                    return [scale * (1 - progress * 2), -scale];
                } else {
                    // Left edge: bottom to top
                    const progress = (phase - 0.75) / 0.25;
                    return [-scale, scale * (progress * 2 - 1)];
                }
            }

            getName() {
                return 'Square';
            }
        }

        /**
         * Spiral trajectory generator - varying speed
         */
        class SpiralGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const phase = t * 4 * Math.PI / maxTime; // 2 full spirals
                const radius = scale * (0.2 + 0.8 * t / maxTime); // Growing radius
                const x = radius * Math.cos(phase);
                const y = radius * Math.sin(phase);
                return [x, y];
            }

            getName() {
                return 'Spiral';
            }
        }

        /**
         * Heart shape trajectory generator - smooth parametric curve
         */
        class HeartGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const phase = t * 6 * Math.PI / maxTime; // 3 hearts in maxTime
                // Parametric heart equation
                const x = scale * 0.8 * (16 * Math.sin(phase)**3) / 16;
                const y = scale * 0.8 * (13 * Math.cos(phase) - 5 * Math.cos(2*phase) - 2 * Math.cos(3*phase) - Math.cos(4*phase)) / 16;
                return [x, -y]; // Flip Y to make heart upright
            }

            getName() {
                return 'Heart';
            }
        }

        /**
         * Star trajectory generator - sharp points and straight segments
         */
        class StarGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const cycleTime = maxTime / 2; // 2 stars in maxTime
                const phase = ((t % cycleTime) / cycleTime) * 10; // 0 to 10 for 5-pointed star
                const pointIndex = Math.floor(phase);
                const progress = phase - pointIndex;

                const outerRadius = scale;
                const innerRadius = scale * 0.4;

                // 5-pointed star: alternate between outer and inner points
                const getStarPoint = (index, outer) => {
                    const angle = (index * 2 * Math.PI / 10) - Math.PI / 2; // Start at top
                    const radius = outer ? outerRadius : innerRadius;
                    return [radius * Math.cos(angle), radius * Math.sin(angle)];
                };

                const isOuter = pointIndex % 2 === 0;
                const currentPoint = getStarPoint(pointIndex, isOuter);
                const nextPoint = getStarPoint((pointIndex + 1) % 10, !isOuter);

                // Linear interpolation between points
                const x = currentPoint[0] + progress * (nextPoint[0] - currentPoint[0]);
                const y = currentPoint[1] + progress * (nextPoint[1] - currentPoint[1]);

                return [x, y];
            }

            getName() {
                return 'Star';
            }
        }

        /**
         * Random walk trajectory generator - stochastic motion
         */
        class RandomWalkGenerator extends TrajectoryGenerator {
            constructor(config = {}) {
                super(config);
                this.positions = [];
                this.generateWalk();
            }

            generateWalk() {
                const { maxTime, scale } = this.config;
                const dt = 0.05;
                const steps = Math.ceil(maxTime / dt);
                const stepSize = scale * 0.02;

                let x = 0, y = 0;
                this.positions = [];

                for (let i = 0; i <= steps; i++) {
                    this.positions.push([x, y]);

                    // Random step
                    const angle = Math.random() * 2 * Math.PI;
                    x += stepSize * Math.cos(angle);
                    y += stepSize * Math.sin(angle);

                    // Keep within bounds
                    const maxPos = scale * 1.2;
                    x = Math.max(-maxPos, Math.min(maxPos, x));
                    y = Math.max(-maxPos, Math.min(maxPos, y));
                }
            }

            generatePosition(t) {
                const dt = 0.05;
                const index = Math.min(Math.floor(t / dt), this.positions.length - 1);
                return this.positions[index];
            }

            getName() {
                return 'Random Walk';
            }
        }

        /**
         * Infinity symbol (∞) trajectory generator - another smooth curve
         */
        class InfinityGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const phase = t * 6 * Math.PI / maxTime; // 3 infinity symbols in maxTime
                // Parametric infinity curve (lemniscate)
                const x = scale * Math.cos(phase) / (1 + Math.sin(phase)**2);
                const y = scale * Math.sin(phase) * Math.cos(phase) / (1 + Math.sin(phase)**2);
                return [x, y];
            }

            getName() {
                return 'Infinity (∞)';
            }
        }

        /**
         * Straight line with constant velocity - back and forth
         */
        class ConstantVelocityGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const cycleTime = maxTime / 3; // 3 back-and-forth cycles
                const phase = (t % cycleTime) / cycleTime; // 0 to 1 for one cycle

                // Linear motion: 0->1->0 over one cycle
                let progress;
                if (phase <= 0.5) {
                    progress = phase * 2; // 0 to 1
                } else {
                    progress = 2 - phase * 2; // 1 to 0
                }

                const x = scale * (progress * 2 - 1); // -scale to +scale
                const y = 0; // horizontal line
                return [x, y];
            }

            getName() {
                return 'Constant Velocity Line';
            }
        }

        /**
         * Straight line with constant acceleration - back and forth
         */
        class ConstantAccelerationGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const cycleTime = maxTime / 3; // 3 back-and-forth cycles
                const phase = (t % cycleTime) / cycleTime; // 0 to 1 for one cycle

                // Quadratic motion for constant acceleration
                let progress;
                if (phase <= 0.5) {
                    // Accelerating from 0 to max, then decelerating to middle
                    const localPhase = phase * 2; // 0 to 1
                    progress = localPhase * localPhase; // quadratic: 0 to 1
                } else {
                    // Accelerating from middle to 0
                    const localPhase = (phase - 0.5) * 2; // 0 to 1
                    progress = 1 - localPhase * localPhase; // quadratic: 1 to 0
                }

                const x = scale * (progress * 2 - 1); // -scale to +scale
                const y = 0; // horizontal line
                return [x, y];
            }

            getName() {
                return 'Constant Acceleration Line';
            }
        }

        /**
         * Sine wave trajectory - smooth 1D oscillation
         */
        class SineWaveGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const frequency = 6 / maxTime; // 6 complete waves over maxTime
                const x = scale * Math.sin(2 * Math.PI * frequency * t);
                const y = 0; // horizontal oscillation
                return [x, y];
            }

            getName() {
                return 'Sine Wave';
            }
        }

        /**
         * Parabolic trajectory - projectile motion
         */
        class ParabolicGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const cycleTime = maxTime / 2; // 2 parabolic arcs
                const phase = (t % cycleTime) / cycleTime; // 0 to 1 for one arc

                // Parabolic trajectory: y = -a*x^2 + height
                const x = scale * (phase * 2 - 1); // -scale to +scale
                const height = scale * 0.8;
                const y = height * (1 - 4 * phase * (1 - phase)); // parabola peaking at 0.5

                return [x, y];
            }

            getName() {
                return 'Parabolic Arc';
            }
        }

        /**
         * Step function - sudden position changes
         */
        class StepFunctionGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const stepDuration = maxTime / 6; // 6 steps total
                const stepIndex = Math.floor(t / stepDuration);

                // Alternating positions
                const positions = [
                    [-scale, -scale * 0.5],
                    [scale, -scale * 0.5],
                    [-scale, scale * 0.5],
                    [scale, scale * 0.5],
                    [0, -scale],
                    [0, scale]
                ];

                return positions[stepIndex % positions.length];
            }

            getName() {
                return 'Step Function';
            }
        }

        /**
         * Stop and go - periods of motion and rest
         */
        class StopAndGoGenerator extends TrajectoryGenerator {
            generatePosition(t) {
                const { maxTime, scale } = this.config;
                const cycleDuration = maxTime / 4; // 4 cycles
                const phase = (t % cycleDuration) / cycleDuration; // 0 to 1 per cycle

                let x, y;
                if (phase < 0.7) {
                    // Moving phase (70% of cycle)
                    const movePhase = phase / 0.7; // 0 to 1
                    const angle = (Math.floor(t / cycleDuration) % 4) * Math.PI / 2; // 0, π/2, π, 3π/2
                    x = scale * movePhase * Math.cos(angle);
                    y = scale * movePhase * Math.sin(angle);
                } else {
                    // Stopped phase (30% of cycle) - hold last position
                    const angle = (Math.floor(t / cycleDuration) % 4) * Math.PI / 2;
                    x = scale * Math.cos(angle);
                    y = scale * Math.sin(angle);
                }

                return [x, y];
            }

            getName() {
                return 'Stop and Go';
            }
        }

        // ================================
        // FILTER INTERFACES
        // ================================

        /**
         * Base class for all filters
         * Extend this to implement different filter types
         */
        class FilterBase {
            constructor(config = {}) {
                this.config = config;
                this.lastInnovation = null;
                this.lastKalmanGain = null;
                this.lastInnovationCovariance = null;
            }

            /**
             * Prediction step - must be implemented by subclass
             */
            predict() {
                throw new Error('predict must be implemented by subclass');
            }

            /**
             * Update step with measurement - must be implemented by subclass
             * @param {Array} measurement - measurement vector
             */
            update(measurement) {
                throw new Error('update must be implemented by subclass');
            }

            /**
             * Get current state estimate
             */
            getState() {
                return this.state;
            }

            /**
             * Get position estimate [x, y]
             */
            getPosition() {
                if (!this.state || this.state.length < 2) return [0, 0];
                return [this.state[0][0], this.state[1][0]];
            }

            /**
             * Get position covariance matrix
             */
            getPositionCovariance() {
                if (!this.covariance) return [[1, 0], [0, 1]];
                return MatrixUtils.extractSubmatrix(this.covariance, 0, 1, 0, 1);
            }

            /**
             * Get system matrices for display
             */
            getSystemMatrices() {
                return {};
            }

            /**
             * Get filter name for display
             */
            getName() {
                return 'Generic Filter';
            }
        }

        /**
         * 2D Kalman Filter implementation
         */
        class KalmanFilter2D extends FilterBase {
            constructor(config = {}) {
                super(config);
                const { dt, measurementNoise, processNoise } = {
                    dt: 0.05,
                    measurementNoise: 15,
                    processNoise: 1,
                    ...config
                };

                this.dt = dt;

                // State vector: [x, y, vx, vy, ax, ay]
                this.state = [[0], [0], [0], [0], [0], [0]];

                // State transition matrix (constant acceleration model)
                this.F = [
                    [1, 0, dt, 0, 0.5*dt*dt, 0],
                    [0, 1, 0, dt, 0, 0.5*dt*dt],
                    [0, 0, 1, 0, dt, 0],
                    [0, 0, 0, 1, 0, dt],
                    [0, 0, 0, 0, 1, 0],
                    [0, 0, 0, 0, 0, 1]
                ];

                // Measurement matrix (we only measure position)
                this.H = [
                    [1, 0, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0, 0]
                ];

                // Process covariance
                this.covariance = MatrixUtils.identity(6).map(row => row.map(val => val * 100));

                // Process noise covariance
                const q = processNoise;
                this.Q = [
                    [dt**4/4 * q, 0, dt**3/2 * q, 0, dt**2/2 * q, 0],
                    [0, dt**4/4 * q, 0, dt**3/2 * q, 0, dt**2/2 * q],
                    [dt**3/2 * q, 0, dt**2 * q, 0, dt * q, 0],
                    [0, dt**3/2 * q, 0, dt**2 * q, 0, dt * q],
                    [dt**2/2 * q, 0, dt * q, 0, q, 0],
                    [0, dt**2/2 * q, 0, dt * q, 0, q]
                ];

                // Measurement noise covariance
                this.R = [
                    [measurementNoise * measurementNoise, 0],
                    [0, measurementNoise * measurementNoise]
                ];
            }

            predict() {
                // Predict state
                this.state = MatrixUtils.multiply(this.F, this.state);

                // Predict covariance
                const FP = MatrixUtils.multiply(this.F, this.covariance);
                const FPFt = MatrixUtils.multiply(FP, MatrixUtils.transpose(this.F));
                this.covariance = MatrixUtils.add(FPFt, this.Q);

                // Clear measurement-related values after prediction
                this.lastInnovation = null;
                this.lastKalmanGain = null;
                this.lastInnovationCovariance = null;
            }

            update(measurement) {
                // Innovation
                const innovation = MatrixUtils.subtract(measurement, MatrixUtils.multiply(this.H, this.state));
                this.lastInnovation = innovation;

                // Innovation covariance
                const HP = MatrixUtils.multiply(this.H, this.covariance);
                const HPHt = MatrixUtils.multiply(HP, MatrixUtils.transpose(this.H));
                const S = MatrixUtils.add(HPHt, this.R);
                this.lastInnovationCovariance = S;

                // Kalman gain
                const PHt = MatrixUtils.multiply(this.covariance, MatrixUtils.transpose(this.H));
                const K = MatrixUtils.multiply(PHt, MatrixUtils.inverse2x2(S));
                this.lastKalmanGain = K;

                // Update state
                const Ky = MatrixUtils.multiply(K, innovation);
                this.state = MatrixUtils.add(this.state, Ky);

                // Update covariance
                const KH = MatrixUtils.multiply(K, this.H);
                const I_KH = MatrixUtils.subtract(MatrixUtils.identity(6), KH);
                this.covariance = MatrixUtils.multiply(I_KH, this.covariance);
            }

            getSystemMatrices() {
                return {
                    F: this.F,
                    H: this.H,
                    Q: this.Q,
                    R: this.R
                };
            }

            getName() {
                return 'Kalman Filter 2D';
            }

            // Update noise parameters
            updateNoise(measurementNoise, processNoise) {
                const q = processNoise;
                const dt = this.dt;

                this.Q = [
                    [dt**4/4 * q, 0, dt**3/2 * q, 0, dt**2/2 * q, 0],
                    [0, dt**4/4 * q, 0, dt**3/2 * q, 0, dt**2/2 * q],
                    [dt**3/2 * q, 0, dt**2 * q, 0, dt * q, 0],
                    [0, dt**3/2 * q, 0, dt**2 * q, 0, dt * q],
                    [dt**2/2 * q, 0, dt * q, 0, q, 0],
                    [0, dt**2/2 * q, 0, dt * q, 0, q]
                ];

                this.R = [
                    [measurementNoise * measurementNoise, 0],
                    [0, measurementNoise * measurementNoise]
                ];
            }
        }

        // ================================
        // VISUALIZATION ENGINE
        // ================================

        /**
         * Handles all canvas visualization
         */
        class VisualizationEngine {
            constructor(canvasId, config = {}) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.config = {
                    fadeWindowSeconds: 6.0,
                    minAlpha: 0.06,
                    fadeSharpness: 2.5,
                    ...config
                };
            }

            /**
             * Calculate fade alpha based on age
             */
            fadeAlphaFromAge(ageSeconds) {
                if (ageSeconds <= 0) return 1.0;
                const base = Math.exp(-ageSeconds / this.config.fadeWindowSeconds);
                const shaped = Math.pow(base, this.config.fadeSharpness);
                return Math.max(this.config.minAlpha, shaped);
            }

            /**
             * Draw error ellipse
             */
            drawErrorEllipse(x, y, cov, confidence = 0.95) {
                const chi2 = 5.991; // 95% confidence for 2D

                const a = cov[0][0];
                const b = cov[0][1];
                const c = cov[1][1];

                const trace = a + c;
                const det = a * c - b * b;
                const disc = Math.sqrt(Math.max(0, trace * trace - 4 * det));

                const lambda1 = (trace + disc) / 2;
                const lambda2 = (trace - disc) / 2;
                const angle = Math.atan2(lambda1 - a, b);

                const width = 2 * Math.sqrt(Math.max(0, lambda1 * chi2));
                const height = 2 * Math.sqrt(Math.max(0, lambda2 * chi2));

                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(angle);
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, width, height, 0, 0, 2 * Math.PI);
                this.ctx.restore();
            }

            /**
             * Main draw function
             */
            draw(data) {
                const { currentTime, dt, groundTruth, measurements, estimates, covariances } = data;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);

                const timeIndex = Math.floor(currentTime / dt);

                // Draw ground truth trail
                this.ctx.globalAlpha = 0.3;
                this.ctx.strokeStyle = '#0f0';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                for (let i = 0; i <= timeIndex && i < groundTruth.length; i++) {
                    const [x, y] = groundTruth[i];
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.stroke();

                // Draw historical estimates with error ellipses (faded by age, every 2nd point for performance)
                for (let i = 0; i < timeIndex && i < estimates.length; i += 2) {
                    const t = i * dt;
                    const age = currentTime - t;
                    const a = this.fadeAlphaFromAge(age);

                    // Historical ellipses (faded)
                    this.ctx.globalAlpha = a * 0.15;
                    this.ctx.strokeStyle = 'rgba(0,255,255,1)';
                    this.ctx.fillStyle = 'rgba(0,255,255,1)';
                    this.ctx.lineWidth = 1;
                    this.drawErrorEllipse(estimates[i][0], estimates[i][1], covariances[i]);
                    this.ctx.stroke();

                    this.ctx.globalAlpha = a * 0.05;
                    this.ctx.fill();

                    // Historical estimate dot
                    this.ctx.globalAlpha = a * 0.5;
                    this.ctx.fillStyle = '#0ff';
                    this.ctx.beginPath();
                    this.ctx.arc(estimates[i][0], estimates[i][1], 2, 0, 2 * Math.PI);
                    this.ctx.fill();
                }

                // Draw measurements (faded by age)
                this.ctx.globalAlpha = 1.0;
                measurements.forEach(m => {
                    if (m.time <= currentTime) {
                        const age = currentTime - m.time;
                        const a = this.fadeAlphaFromAge(age);
                        this.ctx.globalAlpha = a;
                        this.ctx.fillStyle = '#f0f';
                        this.ctx.beginPath();
                        this.ctx.arc(m.pos[0], m.pos[1], 3, 0, 2 * Math.PI);
                        this.ctx.fill();
                    }
                });

                // Draw current positions (ALWAYS draw these regardless of measurement status)
                this.ctx.globalAlpha = 1.0;
                if (timeIndex < groundTruth.length && timeIndex < estimates.length) {
                    // Current ground truth
                    this.ctx.fillStyle = '#0f0';
                    this.ctx.beginPath();
                    this.ctx.arc(groundTruth[timeIndex][0], groundTruth[timeIndex][1], 6, 0, 2 * Math.PI);
                    this.ctx.fill();

                    // Current error ellipse
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.strokeStyle = 'rgba(0, 255, 255, 1)';
                    this.ctx.lineWidth = 2;
                    this.drawErrorEllipse(estimates[timeIndex][0], estimates[timeIndex][1], covariances[timeIndex]);
                    this.ctx.stroke();

                    this.ctx.globalAlpha = 0.05;
                    this.ctx.fillStyle = 'rgba(0, 255, 255, 1)';
                    this.ctx.fill();

                    // Current Kalman estimate - ALWAYS VISIBLE
                    this.ctx.globalAlpha = 1.0;
                    this.ctx.fillStyle = '#0ff';
                    this.ctx.beginPath();
                    this.ctx.arc(estimates[timeIndex][0], estimates[timeIndex][1], 6, 0, 2 * Math.PI);
                    this.ctx.fill();
                }

                this.ctx.restore();
            }
        }

        // ================================
        // STATE DISPLAY ENGINE
        // ================================

        /**
         * Manages the state panel display
         */
        class StateDisplayEngine {
            constructor() {
                this.elements = this.cacheElements();
            }

            cacheElements() {
                return {
                    measurementStatus: document.getElementById('measurementStatus'),
                    stateX: document.getElementById('state-x'),
                    stateY: document.getElementById('state-y'),
                    stateVx: document.getElementById('state-vx'),
                    stateVy: document.getElementById('state-vy'),
                    stateAx: document.getElementById('state-ax'),
                    stateAy: document.getElementById('state-ay'),
                    p00: document.getElementById('p00'),
                    p01: document.getElementById('p01'),
                    p10: document.getElementById('p10'),
                    p11: document.getElementById('p11'),
                    posError: document.getElementById('pos-error'),
                    stdX: document.getElementById('std-x'),
                    stdY: document.getElementById('std-y'),
                    innovationX: document.getElementById('innovation-x'),
                    innovationY: document.getElementById('innovation-y'),
                    kalmanGainElements: [
                        'k00', 'k01', 'k10', 'k11', 'k20', 'k21',
                        'k30', 'k31', 'k40', 'k41', 'k50', 'k51'
                    ].map(id => ({ id, element: document.getElementById(id) }))
                };
            }

            displayMatrix(matrix, elementId) {
                const container = document.getElementById(elementId);
                if (!container) return;

                container.innerHTML = '';
                matrix.forEach(row => {
                    row.forEach(val => {
                        const cell = document.createElement('div');
                        cell.className = 'matrix-cell';
                        const num = typeof val === 'number' ? val : 0;
                        if (Math.abs(num) < 0.001 && num !== 0) {
                            cell.textContent = num.toExponential(1);
                        } else if (Math.abs(num) < 0.01) {
                            cell.textContent = num.toFixed(4);
                        } else {
                            cell.textContent = num.toFixed(3);
                        }
                        container.appendChild(cell);
                    });
                });
            }

            updateDisplay(filterState, groundTruth, systemMatrices, showMatrices) {
                const { state, covariance, innovation, kalmanGain, innovationCovariance, hadMeasurement } = filterState;

                // Update state vector
                this.elements.stateX.textContent = state[0].toFixed(2);
                this.elements.stateY.textContent = state[1].toFixed(2);
                this.elements.stateVx.textContent = state[2].toFixed(2);
                this.elements.stateVy.textContent = state[3].toFixed(2);
                this.elements.stateAx.textContent = state[4].toFixed(2);
                this.elements.stateAy.textContent = state[5].toFixed(2);

                // Update position covariance
                this.elements.p00.textContent = covariance[0][0].toFixed(2);
                this.elements.p01.textContent = covariance[0][1].toFixed(2);
                this.elements.p10.textContent = covariance[1][0].toFixed(2);
                this.elements.p11.textContent = covariance[1][1].toFixed(2);

                // Update error metrics
                const posError = Math.sqrt(
                    Math.pow(state[0] - groundTruth[0], 2) +
                    Math.pow(state[1] - groundTruth[1], 2)
                );
                this.elements.posError.textContent = posError.toFixed(2);
                this.elements.stdX.textContent = Math.sqrt(covariance[0][0]).toFixed(2);
                this.elements.stdY.textContent = Math.sqrt(covariance[1][1]).toFixed(2);

                // Update measurement status and innovation/gain
                if (hadMeasurement) {
                    this.elements.measurementStatus.textContent = 'Measurement Update';
                    this.elements.measurementStatus.className = 'measurement-indicator';
                    this.updateInnovationAndGain(innovation, kalmanGain, false);
                } else {
                    this.elements.measurementStatus.textContent = 'Prediction Only';
                    this.elements.measurementStatus.className = 'measurement-indicator no-measurement';
                    this.updateInnovationAndGain(innovation, kalmanGain, true);
                }

                // Update system matrices if visible
                if (showMatrices && systemMatrices) {
                    this.displayMatrix(systemMatrices.F, 'matrix-F');
                    this.displayMatrix(systemMatrices.H, 'matrix-H');
                    this.displayMatrix(systemMatrices.Q, 'matrix-Q');
                    this.displayMatrix(systemMatrices.R, 'matrix-R');
                    this.displayMatrix(covariance, 'matrix-P-full');

                    if (innovationCovariance) {
                        this.displayMatrix(innovationCovariance, 'matrix-S');
                    } else {
                        document.getElementById('matrix-S').innerHTML = '<div class="matrix-cell inactive">Not computed (prediction only)</div>';
                    }
                }
            }

            updateInnovationAndGain(innovation, kalmanGain, inactive) {
                // Update innovation - show values if available, otherwise show "--"
                if (innovation) {
                    this.elements.innovationX.textContent = innovation[0].toFixed(2);
                    this.elements.innovationY.textContent = innovation[1].toFixed(2);

                    // Manage inactive class properly
                    if (inactive) {
                        this.elements.innovationX.classList.add('inactive');
                        this.elements.innovationY.classList.add('inactive');
                    } else {
                        this.elements.innovationX.classList.remove('inactive');
                        this.elements.innovationY.classList.remove('inactive');
                    }
                } else {
                    this.elements.innovationX.textContent = '--';
                    this.elements.innovationY.textContent = '--';
                    this.elements.innovationX.classList.add('inactive');
                    this.elements.innovationY.classList.add('inactive');
                }

                // Update Kalman gain - show values if available, otherwise show "--"
                if (kalmanGain) {
                    this.elements.kalmanGainElements.forEach(({ element }, index) => {
                        const row = Math.floor(index / 2);
                        const col = index % 2;
                        element.textContent = kalmanGain[row][col].toFixed(3);

                        // Manage inactive class properly
                        if (inactive) {
                            element.classList.add('inactive');
                        } else {
                            element.classList.remove('inactive');
                        }
                    });
                } else {
                    this.elements.kalmanGainElements.forEach(({ element }) => {
                        element.textContent = '--';
                        element.classList.add('inactive');
                    });
                }
            }
        }

        // ================================
        // UI CONTROLLER
        // ================================

        /**
         * Manages all UI interactions
         */
        class UIController {
            constructor(simulationController) {
                this.sim = simulationController;
                this.initializeControls();
            }

            initializeControls() {
                // Trajectory selector
                document.getElementById('trajectorySelect').addEventListener('change', (e) => {
                    this.sim.setTrajectoryType(e.target.value);
                });

                // Time slider
                const timeSlider = document.getElementById('timeSlider');
                const timeValue = document.getElementById('timeValue');
                timeSlider.max = this.sim.config.maxTime / this.sim.config.dt;

                timeSlider.addEventListener('input', (e) => {
                    this.sim.setTime(e.target.value * this.sim.config.dt);
                    timeValue.textContent = this.sim.currentTime.toFixed(2) + 's';
                });

                // Noise controls
                document.getElementById('measurementNoise').addEventListener('input', (e) => {
                    document.getElementById('measurementNoiseValue').textContent = e.target.value;
                    this.sim.updateNoiseParams();
                });

                document.getElementById('processNoise').addEventListener('input', (e) => {
                    document.getElementById('processNoiseValue').textContent = e.target.value;
                    this.sim.updateNoiseParams();
                });

                // Control buttons
                document.getElementById('playBtn').addEventListener('click', () => {
                    this.sim.togglePlay();
                });

                document.getElementById('stepBtn').addEventListener('click', () => {
                    this.sim.step();
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.sim.reset();
                });

                // Matrix visibility toggle
                document.getElementById('toggleMatrices').addEventListener('click', () => {
                    const section = document.getElementById('matricesSection');
                    const toggle = document.getElementById('toggleMatrices');
                    const isVisible = section.classList.toggle('visible');
                    toggle.textContent = isVisible ?
                        'Hide System Matrices & Equations ▲' :
                        'Show System Matrices & Equations ▼';
                    this.sim.setMatrixVisibility(isVisible);
                });
            }

            updateTimeDisplay() {
                document.getElementById('timeSlider').value = this.sim.currentTime / this.sim.config.dt;
                document.getElementById('timeValue').textContent = this.sim.currentTime.toFixed(2) + 's';
            }
        }

        // ================================
        // MAIN SIMULATION CONTROLLER
        // ================================

        /**
         * Orchestrates all components - this is where you swap implementations
         */
        class SimulationController {
            constructor(config = {}) {
                this.config = {
                    maxTime: 30,
                    dt: 0.05,
                    measurementRate: 0.1,
                    ...config
                };

                // Current trajectory type
                this.trajectoryType = 'figure8';

                // EASILY SWAPPABLE COMPONENTS - Change these to swap implementations
                this.trajectoryGenerator = this.createTrajectoryGenerator();

                this.filter = new KalmanFilter2D({
                    dt: this.config.dt,
                    measurementNoise: 15,
                    processNoise: 1
                });

                // Initialize other components
                this.visualization = new VisualizationEngine('canvas');
                this.stateDisplay = new StateDisplayEngine();

                // Simulation state
                this.currentTime = 0;
                this.playing = false;
                this.showMatrices = false;

                // Data storage
                this.groundTruth = [];
                this.measurements = [];
                this.estimates = [];
                this.covariances = [];
                this.filterStates = [];

                // Generate initial data
                this.generateData();
            }

            /**
             * TO SWAP FILTER: Change this method
             */
            createFilter() {
                return new KalmanFilter2D({
                    dt: this.config.dt,
                    measurementNoise: this.getMeasurementNoise(),
                    processNoise: this.getProcessNoise()
                });
            }

            /**
             * TO SWAP TRAJECTORY: Change this method
             */
            createTrajectoryGenerator() {
                const config = {
                    maxTime: this.config.maxTime,
                    scale: 150
                };

                switch (this.trajectoryType) {
                    case 'figure8':
                        return new Figure8Generator(config);
                    case 'circle':
                        return new CircleGenerator(config);
                    case 'constantvelocity':
                        return new ConstantVelocityGenerator(config);
                    case 'constantacceleration':
                        return new ConstantAccelerationGenerator(config);
                    case 'sinewave':
                        return new SineWaveGenerator(config);
                    case 'parabolic':
                        return new ParabolicGenerator(config);
                    case 'square':
                        return new SquareGenerator(config);
                    case 'spiral':
                        return new SpiralGenerator(config);
                    case 'heart':
                        return new HeartGenerator(config);
                    case 'star':
                        return new StarGenerator(config);
                    case 'infinity':
                        return new InfinityGenerator(config);
                    case 'stepfunction':
                        return new StepFunctionGenerator(config);
                    case 'stopandgo':
                        return new StopAndGoGenerator(config);
                    case 'randomwalk':
                        return new RandomWalkGenerator(config);
                    default:
                        return new Figure8Generator(config);
                }
            }

            getMeasurementNoise() {
                return parseFloat(document.getElementById('measurementNoise').value);
            }

            getProcessNoise() {
                return parseFloat(document.getElementById('processNoise').value);
            }

            generateData() {
                // Clear existing data
                this.groundTruth = [];
                this.measurements = [];
                this.estimates = [];
                this.covariances = [];
                this.filterStates = [];

                // Create fresh filter instance
                this.filter = this.createFilter();
                const measurementNoise = this.getMeasurementNoise();
                let lastMeasurementTime = 0;

                // Track last measurement-related values to preserve across prediction steps
                let lastInnovation = null;
                let lastKalmanGain = null;
                let lastInnovationCovariance = null;

                // Generate full simulation data
                for (let t = 0; t <= this.config.maxTime; t += this.config.dt) {
                    // Generate ground truth
                    const truth = this.trajectoryGenerator.generatePosition(t);
                    this.groundTruth.push(truth);

                    // Predict step (always)
                    this.filter.predict();

                    // Update step (only at measurement rate)
                    let hadMeasurement = false;
                    if (t - lastMeasurementTime >= this.config.measurementRate - this.config.dt/2) {
                        const measurement = NoiseUtils.addGaussianNoise(truth, measurementNoise);
                        this.measurements.push({ time: t, pos: measurement });
                        this.filter.update([[measurement[0]], [measurement[1]]]);
                        lastMeasurementTime = t;
                        hadMeasurement = true;

                        // Store the new measurement-related values
                        if (this.filter.lastInnovation) {
                            lastInnovation = [...this.filter.lastInnovation.map(row => row[0])];
                        }
                        if (this.filter.lastKalmanGain) {
                            lastKalmanGain = this.filter.lastKalmanGain.map(row => [...row]);
                        }
                        if (this.filter.lastInnovationCovariance) {
                            lastInnovationCovariance = this.filter.lastInnovationCovariance.map(row => [...row]);
                        }
                    }

                    // Store results
                    const position = this.filter.getPosition();
                    this.estimates.push(position);
                    this.covariances.push(this.filter.getPositionCovariance());

                    this.filterStates.push({
                        state: [...this.filter.getState().map(row => row[0])],
                        covariance: this.filter.covariance.map(row => [...row]),
                        innovation: lastInnovation, // Always the last known values
                        kalmanGain: lastKalmanGain, // Always the last known values
                        innovationCovariance: lastInnovationCovariance, // Always the last known values
                        hadMeasurement: hadMeasurement
                    });
                }
            }

            updateNoiseParams() {
                if (this.filter.updateNoise) {
                    this.filter.updateNoise(this.getMeasurementNoise(), this.getProcessNoise());
                }
                this.generateData();
                this.draw();
            }

            setTime(newTime) {
                this.currentTime = Math.max(0, Math.min(newTime, this.config.maxTime));
                this.draw();
            }

            togglePlay() {
                this.playing = !this.playing;
            }

            step() {
                this.playing = false;
                this.currentTime += this.config.dt;
                if (this.currentTime > this.config.maxTime) {
                    this.currentTime = 0;
                }
                this.ui.updateTimeDisplay();
                this.draw();
            }

            reset() {
                this.playing = false;
                this.currentTime = 0;
                this.generateData();
                this.ui.updateTimeDisplay();
                this.draw();
            }

            setMatrixVisibility(visible) {
                this.showMatrices = visible;
                this.draw();
            }

            setTrajectoryType(trajectoryType) {
                this.trajectoryType = trajectoryType;
                this.trajectoryGenerator = this.createTrajectoryGenerator();
                this.generateData();
                this.currentTime = 0;
                if (this.ui) {
                    this.ui.updateTimeDisplay();
                }
                this.draw();
            }

            draw() {
                // Update visualization
                this.visualization.draw({
                    currentTime: this.currentTime,
                    dt: this.config.dt,
                    groundTruth: this.groundTruth,
                    measurements: this.measurements,
                    estimates: this.estimates,
                    covariances: this.covariances
                });

                // Update state display
                const timeIndex = Math.floor(this.currentTime / this.config.dt);
                if (timeIndex < this.filterStates.length) {
                    this.stateDisplay.updateDisplay(
                        this.filterStates[timeIndex],
                        this.groundTruth[timeIndex],
                        this.filter.getSystemMatrices(),
                        this.showMatrices
                    );
                }
            }

            animate() {
                if (this.playing) {
                    this.currentTime += this.config.dt;
                    if (this.currentTime > this.config.maxTime) {
                        this.currentTime = 0;
                    }
                    if (this.ui) {
                        this.ui.updateTimeDisplay();
                    }
                    this.draw();
                }
                requestAnimationFrame(() => this.animate());
            }

            start() {
                this.ui = new UIController(this);
                this.draw();
                this.animate();
            }
        }

        // ================================
        // APPLICATION STARTUP
        // ================================

        /**
         * Main application entry point
         * TO SWAP IMPLEMENTATIONS: Modify the config or component creation here
         */
        function startApplication() {
            const config = {
                maxTime: 30,
                dt: 0.05,
                measurementRate: 0.1
            };

            const simulation = new SimulationController(config);
            simulation.start();
        }

        // Start the application
        startApplication();
    </script>
</body>
</html>
